
  <style>
    /* 03JUN2025 2316 - last commit prior to skill level refactor*/
    :root {
      /* --domain-count: 8; /* ← TEMPORARY fallback for CSS grid */

      

      /* Base color palette */
      --color-green: #70AD47;
      --color-teal: #008080;
      --color-orange: #fa8e36;
      --color-yellow: #e4ac03;
      --color-black: #2a2a2a;
      --color-purple: #683e9b;
      --color-skyblue: #6bb3f6;
      --color-blue: #2e5688;
      --color-red: #c0514d;
      --color-magenta: #a500a1;
  /* Extended accent */
  --color-blue-bright: #0000ff; /* Bright blue used for Reach Goal status */
      
      /* Dark variants */      
      --color-green-dark: #548235;
      --color-teal-dark: #003F3E;
      --color-orange-dark: #c06216;
      --color-yellow-dark: #7F6000;
      --color-black-dark: #000000;
      --color-purple-dark: #352647;
      --color-skyblue-dark: #2665a0;
      --color-blue-dark: #1f3147;
      --color-red-dark: #8c3736;
      --color-magenta-dark: #490e49;
      
      /* Light variants */
      --color-green-light: #c3dbb8;
      --color-teal-light: #8fc6c6;
      --color-orange-light: #fdeada;
      --color-yellow-light: #f4e7af;
      --color-black-light: #d9d9d9;
      --color-purple-light: #eddbff;
      --color-skyblue-light: #b8e0ff;
      --color-blue-light: #dce6f2;
      --color-red-light: #f2dcdb;
      --color-magenta-light: #f1d4e0;
      
      /* Domain-specific colors */
      --domain-default-white: #ffffff;
      --domain-net: var(--color-green);
      --domain-net-dark: var(--color-green-dark);
      --domain-net-light: var(--color-green-light);
      --domain-iam: var(--color-teal);
      --domain-iam-dark: var(--color-teal-dark);
      --domain-iam-light: var(--color-teal-light);
      --domain-eng: var(--color-orange);
      --domain-eng-dark: var(--color-orange-dark);
      --domain-eng-light: var(--color-orange-light);
      --domain-ast: var(--color-yellow);
      --domain-ast-dark: var(--color-yellow-dark);
      --domain-ast-light: var(--color-yellow-light);
      --domain-rsk: var(--color-black);
      --domain-rsk-dark: var(--color-black-dark);
      --domain-rsk-light: var(--color-black-light);
      --domain-tst: var(--color-purple);
      --domain-tst-dark: var(--color-purple-dark);
      --domain-tst-light: var(--color-purple-light);
      --domain-sof: var(--color-skyblue);
      --domain-sof-dark: var(--color-skyblue-dark);
      --domain-sof-light: var(--color-skyblue-light);
      --domain-ops: var(--color-red);
      --domain-ops-dark: var(--color-red-dark);
      --domain-ops-light: var(--color-red-light);


      --domain-title-height: 2.8vmax;

      /* Scalable sizing tokens */
      --filter-font-size: clamp(0.55rem, 0.9vmax, 14px);
      --filter-label-font-size: var(--filter-font-size);
      --pill-font-size: var(--filter-font-size);
      --pill-padding-y: clamp(0.18rem, 0.32vmax, 0.5rem);
      --pill-padding-x: clamp(0.5rem, 0.72vmax, 0.9rem);
      --pill-radius: 1vmax;
      --pill-border-width: 2px;
      --filter-line-gap: 0.55vmax;
      --filter-stack-vertical-gap: 0.45vmax;
      --filter-label-offset: 0.08vmax;
      --vendor-select-padding-y: clamp(0.18rem, 0.28vmax, 0.4rem);
      --vendor-select-padding-x: clamp(0.45rem, 0.6vmax, 0.8rem);
      --vendor-select-radius: 0.55vmax;
      --focus-ring: 0 0 0 0.15vmax rgba(0,0,0,0.25);
      --filter-row-vertical-padding: 0.18vmax;
      --filter-interline-spacing: 0.4vmax;
      /* Track width tokens (Option C) */
      --cert-track-width: 2.3vmax;   /* Standard certification tile track */
      --skill-track-width: 0.6vmax;  /* Narrow skill column track */
  /* Learner neutral pill scheme */
  --learner-neutral-bg: var(--color-black-light);
  --learner-neutral-border: var(--color-black-dark);
  --learner-neutral-text: var(--color-black-dark);
  --learner-achieved-text: limegreen; /* explicit brighter text */
  --learner-achieved-border: limegreen;
  --learner-planned-text: darkgoldenrod;
  --learner-planned-border: darkgoldenrod;
  --learner-reach-text: var(--color-blue-bright);
  --learner-reach-border: var(--color-blue-bright);
  --learner-reach-bg: #dbe1ff; /* light blue background */
    }

    /* Domain-specific border and title coloring */
    .domain-NET     { border-color: var(--domain-net); }
    .domain-IAM     { border-color: var(--domain-iam); }
    .domain-ENG     { border-color: var(--domain-eng); }
    .domain-AST     { border-color: var(--domain-ast); }
    .domain-RSK     { border-color: var(--domain-rsk); }
    .domain-TST     { border-color: var(--domain-tst); }
    .domain-SOF     { border-color: var(--domain-sof); }
    .domain-OPS     { border-color: var(--domain-ops); }
    .domain-SKL     { border-color: transparent; }  /* No border for skill domain */

    .domain-NET .domain-title {
      background-color: var(--domain-net-light);
      color: var(--domain-net-dark);
    }
    .domain-IAM .domain-title {
      background-color: var(--domain-iam-light);
      color: var(--domain-iam-dark);
    }
    .domain-ENG .domain-title {
      background-color: var(--domain-eng-light);
      color: var(--domain-eng-dark);
    }
    .domain-AST .domain-title {
      background-color: var(--domain-ast-light);
      color: var(--domain-ast-dark);
    }
    .domain-RSK .domain-title {
      background-color: var(--domain-rsk-light);
      color: var(--domain-rsk-dark);
    }
    .domain-TST .domain-title {
      background-color: var(--domain-tst-light);
      color: var(--domain-tst-dark);
    }
    .domain-SOF .domain-title {
      background-color: var(--domain-sof-light);
      color: var(--domain-sof-dark);
    }
    .domain-OPS .domain-title {
      background-color: var(--domain-ops-light);
      color: var(--domain-ops-dark);
    }
    .domain-SKL .domain-title {
      background-color: transparent;
      color: var(--color-black-dark);
      border: none;
    }  /* No background or border for skill domain title */

    /* BEGIN Dark Mode Styling */
    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    body.dark-mode .domain-container {
      background-color: #1e1e1e;
      border-color: #444;
    }

    body.dark-mode .cert-tile {
      background-color: inherit;
      border-color: #555;
      color: white;
    }

    body.dark-mode .subdomain-canvas {
      opacity: 0.15; /* Subtle, but visible on dark bg */
    }

    /* END Dark Mode Styling */

    /* Domain Filter Pills */
    #domain-checkboxes.domain-filter-bar {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.35vmax;
      padding: 0.25vmax 0.4vmax;
      overflow-x: auto; /* allow horizontal scroll instead of wrapping */
      overflow-y: hidden;
      white-space: nowrap; /* prevent wrapping */
      scrollbar-width: thin;
    }
    #domain-checkboxes.domain-filter-bar::-webkit-scrollbar {
      height: 0.4vmax;
    }
    #domain-checkboxes.domain-filter-bar::-webkit-scrollbar-track {
      background: #f0f0f0;
    }
    #domain-checkboxes.domain-filter-bar::-webkit-scrollbar-thumb {
      background: #bbb;
      border-radius: 1vmax;
    }
    /* Unified pill styling */
    .domain-filter-tile, .strata-filter-tile, .mode-filter-tile {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: var(--pill-font-size);
      font-weight: 600;
      padding: var(--pill-padding-y) var(--pill-padding-x);
      border-radius: var(--pill-radius);
      border: var(--pill-border-width) solid transparent;
      cursor: pointer;
      user-select: none;
      line-height: 1;
      letter-spacing: 0.5px;
      transition: background-color 0.18s ease, color 0.18s ease, border-color 0.18s ease, opacity 0.18s ease;
      box-shadow: 0 0 0 0 rgba(0,0,0,0);
      white-space: nowrap;
    }
    .domain-filter-tile:focus-within, .strata-filter-tile:focus-within, .mode-filter-tile:focus-within {
      outline: none;
      box-shadow: var(--focus-ring);
    }
    .domain-filter-tile input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
      margin: 0;
      padding: 0;
    }
    .domain-filter-tile.is-off {
      background: transparent !important;
      color: #555 !important;
      border-style: dashed !important;
      opacity: 0.55;
    }
    .domain-filter-tile:hover {
      filter: brightness(1.06);
    }
    body.dark-mode .domain-filter-tile.is-off {
      color: #aaa !important;
      border-color: #555 !important;
    }
    body.dark-mode .domain-filter-tile {
      box-shadow: none;
    }
    /* Filter stack (separate rows) */
  .filter-stack { display:flex; flex-direction:column; gap:var(--filter-stack-vertical-gap); padding:0.4vmax 1vmax 0.3vmax 2vmax; box-sizing:border-box; }
  .filter-stack-header { display:flex; align-items:center; gap:0.5vmax; font-size:0.7vmax; font-weight:600; cursor:pointer; user-select:none; padding:0.25vmax 0.4vmax; width:max-content; border-radius:0.4vmax; transition:background-color .18s; }
  .filter-stack-header:hover { background:rgba(0,0,0,0.05); }
  body.dark-mode .filter-stack-header:hover { background:rgba(255,255,255,0.08); }
  .filter-stack-arrow { display:inline-block; transition:transform .2s ease; font-size:0.8vmax; }
  .filter-stack.collapsed .filter-stack-arrow { transform:rotate(-90deg); }
  .filter-line { display:flex; flex-direction:row; align-items:center; gap:var(--filter-line-gap); flex-wrap:nowrap; padding: var(--filter-row-vertical-padding) 0; }
    .filter-line .domain-filter-bar,
    .filter-line .strata-filter-bar,
    .filter-line .mode-filter-bar { display:flex; flex-direction:row; align-items:stretch; max-width:min(80vw,140vmax); }
  .mode-filter-bar { display:flex; gap:0.35vmax; align-items:center; padding:0.25vmax 0.4vmax; margin-top: var(--filter-interline-spacing); }
  /* .mode-filter-tile intentionally inherits unified pill styling */
    .mode-filter-tile input { position:absolute; opacity:0; pointer-events:none; width:0; height:0; }
    .mode-filter-tile.is-off { background:transparent !important; color:#555 !important; border-style:dashed !important; opacity:.55; }
    .mode-filter-tile:hover { filter:brightness(1.08); }
    body.dark-mode .mode-filter-tile.is-off { color:#aaa !important; border-color:#555 !important; }
    :root { --mode-dark-light: var(--color-black-light); --mode-dark-dark: var(--color-black-dark); }

    /* Unified secondary filter row (Domain + Skill) */
    .filter-row {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 0.9vmax 1vmax; /* row gap then column gap */
      padding: 0.4vmax 1vmax 0.2vmax 2vmax; /* left padding aligns with vendor filter */
      box-sizing: border-box;
    }
    .filter-label {
      font-size: var(--filter-label-font-size);
      font-weight: 600;
      letter-spacing: 0.5px;
      line-height: 1.1;
      white-space: nowrap;
      position: relative;
      top: var(--filter-label-offset);
    }
    .filter-row .domain-filter-bar,
    .filter-row .strata-filter-bar {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      max-width: min(70vw, 120vmax);
    }

    /* Strata Filter Pills (mirrors domain pill styling, slightly different colors) */
    #strata-pills.strata-filter-bar {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.35vmax;
      padding: 0.25vmax 0.4vmax;
      margin-top: var(--filter-interline-spacing);
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      scrollbar-width: thin;
    }
    #strata-pills.strata-filter-bar::-webkit-scrollbar { height: 0.35vmax; }
    #strata-pills.strata-filter-bar::-webkit-scrollbar-track { background: #f4f4f4; }
    #strata-pills.strata-filter-bar::-webkit-scrollbar-thumb { background: #bdbdbd; border-radius: 1vmax; }
  /* .strata-filter-tile intentionally inherits unified pill styling */
    .strata-filter-tile input[type="checkbox"] { position: absolute; opacity: 0; pointer-events: none; width:0; height:0; }
    .strata-filter-tile.is-off { background: transparent !important; color: #555 !important; border-style: dashed !important; opacity: 0.55; }
    .strata-filter-tile:hover { filter: brightness(1.08); }
    body.dark-mode .strata-filter-tile.is-off { color: #aaa !important; border-color: #555 !important; }
    body.dark-mode .strata-filter-tile { box-shadow: none; }
    /* Level-specific color tokens (light/dark pairs) */
    :root {
      /* Strata color mapping updated: Beginner=Green, Intermediate=Yellow, Expert=Red */
      --strata-beginner-light: var(--color-green-light);
      --strata-beginner-dark: var(--color-green-dark);
      --strata-intermediate-light: var(--color-yellow-light);
      --strata-intermediate-dark: var(--color-yellow-dark);
      --strata-expert-light: var(--color-red-light);
      --strata-expert-dark: var(--color-red-dark);
    }

    html, body {
      overflow-x: hidden;
      overflow-y: auto;
      height: 100%;
    }

    body {
      background: white;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    #roadmap-flex {
      display: flex;
      justify-content: flex-start; /* default: left-aligned */
      width: 100%;
    }
    
    body.center-domains #roadmap-flex {
      justify-content: center; /* center when this class is active */
    }

    #roadmap-wrapper {
      display: grid;
      grid-template-columns: 1vmax 1fr; /* LEFT: skill label column, RIGHT: roadmap */
      grid-template-rows: auto auto;
      width: max-content; /* expand to fit roadmap instead of forcing 100% viewport width */
      max-width: none;    /* remove viewport clamp */
      height: auto;
      max-height: none !important;
      overflow: visible;  /* allow roadmap content to be fully visible */
      box-sizing: border-box;
      position: relative;
    }
        
    #roadmap {
      display: flex;
      overflow: visible; /* no clipping */
      width: max-content; /* size to its contents (domains) */
      align-items: start;
      flex-direction: row;
      flex-wrap: nowrap; /* single horizontal row of domains */
      gap: 0.12vmax; /* tightened from 0.2vmax */
      grid-column: 2;
      grid-row: 2;
      max-height: none;
      max-width: none;
      min-width: 0;
      padding-right: 0.2vmax;
    }

    /* Skill Strata Rail */
  :root { --skill-rail-width: 0.9vmax; --skill-rail-gap-right: 0.25vmax; --skill-row-height: 1.5vmax; --skill-label-font-size: 0.55vmax; --skill-rail-top-offset: var(--domain-title-height); }
  #skill-strata-rail { position: relative; display: block; flex: 0 0 var(--skill-rail-width); width: var(--skill-rail-width); margin-right: var(--skill-rail-gap-right); min-height: calc(var(--skill-rail-top-offset) + 28 * var(--skill-row-height)); }
    .skill-strata-segment { position: absolute; left:0; width:100%; box-sizing:border-box; border:1px solid transparent; display:flex; align-items:center; justify-content:center; padding:0.12vmax 0.1vmax; overflow:hidden; border-radius:0.25vmax; transition: opacity .18s ease, filter .18s ease; }
    .skill-strata-segment .strata-label { font-size: var(--skill-label-font-size); font-weight:700; letter-spacing:0.05vmax; text-transform:uppercase; line-height:1; transform:rotate(270deg); white-space:nowrap; color:inherit; pointer-events:none; }
    .skill-strata-segment.strata-expert { background: var(--color-red-light); border-color: var(--color-red-dark); color: var(--color-red-dark); }
    .skill-strata-segment.strata-intermediate { background: var(--color-yellow-light); border-color: var(--color-yellow-dark); color: var(--color-yellow-dark); }
    .skill-strata-segment.strata-beginner { background: var(--color-green-light); border-color: var(--color-green-dark); color: var(--color-green-dark); }
    .skill-strata-segment.is-dimmed { opacity:0.25; filter:grayscale(60%) brightness(1.05); }
    body.dark-mode .skill-strata-segment { filter:brightness(.95) contrast(1.05); }
    body.dark-mode .skill-strata-segment.is-dimmed { opacity:0.28; filter:grayscale(65%) brightness(1.15); }
  /* Learner Mode status styling */
  /* Learner status classes now rely on background + border color only (no outlines) */
  .cert-tile.cert-status-achieved,
  .cert-tile.cert-status-planned,
  .cert-tile.cert-status-reach { outline: none; }
  .learner-popup-menu { position:absolute; z-index:9999; background:#ffffff; border:1px solid #ccc; border-radius:0.45vmax; padding:0.3vmax 0; box-shadow:0 0.4vmax 1vmax rgba(0,0,0,0.18); font-size:0.6vmax; min-width:8vmax; }
  body.dark-mode .learner-popup-menu { background:#222; border-color:#444; box-shadow:0 0.4vmax 1vmax rgba(0,0,0,0.55); }
  .learner-popup-menu button { display:block; width:100%; background:none; border:none; text-align:left; padding:0.38vmax 0.65vmax; cursor:pointer; font-size:inherit; font-family:inherit; color:#222; letter-spacing:0.3px; }
  body.dark-mode .learner-popup-menu button { color:#eee; }
  .learner-popup-menu button:hover, .learner-popup-menu button:focus { background:rgba(0,0,0,0.07); outline:none; }
  body.dark-mode .learner-popup-menu button:hover, body.dark-mode .learner-popup-menu button:focus { background:rgba(255,255,255,0.12); }
  .learner-popup-menu button.danger { color:#a00; }
  .learner-popup-menu button.danger:hover { background:rgba(255,0,0,0.12); }
  /* Popup flips above tile when there isn't space below */
  .learner-popup-menu.placement-above { /* hook */ transform-origin: bottom center; }
  /* Learner status badge (placed in Filters header) */
  .learner-status-badge { display:inline-flex; align-items:center; font-size:0.55vmax; font-weight:600; letter-spacing:0.4px; padding:0.25vmax 0.6vmax; border-radius:var(--pill-radius); border:1px solid transparent; line-height:1; white-space:nowrap; margin-left:auto; }
  .learner-status-badge.learner-status-on { background:var(--color-green-light); color:var(--color-green-dark); border-color:var(--color-green-dark); }
  .learner-status-badge.learner-status-off { background:var(--color-red-light); color:var(--color-red-dark); border-color:var(--color-red-dark); }
  body.dark-mode .learner-status-badge { filter:brightness(.95) contrast(1.05); }
  /* Ensure learner (Options) stack header can flex contents to right-align badge */
  /* Learner stack header should size to its content so badge doesn't push overall layout width */
  #learner-stack-toggle { width:auto; justify-content:flex-start; gap:0.8vmax; }
  /* Reset confirmation modal */
  .learner-reset-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:10000; }
  .learner-reset-dialog { background:#fff; color:#222; padding:1.2vmax 1.4vmax; border-radius:0.6vmax; width:clamp(18rem,28vmax,30rem); box-shadow:0 0.6vmax 2vmax rgba(0,0,0,0.35); font-size:0.7vmax; line-height:1.35; position:relative; }
  body.dark-mode .learner-reset-dialog { background:#1e1e1e; color:#eee; }
  .learner-reset-dialog h3 { margin:0 0 0.8vmax 0; font-size:0.9vmax; }
  .learner-reset-actions { display:flex; gap:0.6vmax; justify-content:flex-end; margin-top:1vmax; }
  .learner-reset-btn { font:inherit; padding:0.4vmax 0.9vmax; border-radius:0.5vmax; cursor:pointer; font-weight:600; border:2px solid transparent; letter-spacing:0.4px; background:var(--color-black-light); color:var(--color-black-dark); }
  .learner-reset-btn:focus { outline:none; box-shadow:var(--focus-ring); }
  body.dark-mode .learner-reset-btn { background:#333; color:#ddd; }
  .learner-reset-btn.confirm { background:var(--color-red-light); color:var(--color-red-dark); border-color:var(--color-red-dark); }
  .learner-reset-btn.confirm:hover { filter:brightness(1.05); }
  .learner-reset-btn.cancel { background:var(--color-purple-light); color:var(--color-purple-dark); border-color:var(--color-purple-dark); }
  .learner-reset-btn.cancel:hover { filter:brightness(1.05); }
  .learner-reset-dialog p { margin:0; }
  /* Reach replace dialog variant (shares base reset dialog styles) */
  .reach-replace-dialog h3 { color: var(--color-blue-dark); }
  body.dark-mode .reach-replace-dialog h3 { color: var(--color-skyblue-light); }
  /* Planned limit dialog variant */
  .planned-limit-dialog h3 { color: var(--color-yellow-dark); }
  body.dark-mode .planned-limit-dialog h3 { color: var(--color-yellow-light); }
  /* Constrained overall layout shell to prevent helper UI from widening page */
  #app-shell { max-width:1600px; margin:0 auto; padding:0 1.5rem 2rem; box-sizing:border-box; }
  @media (max-width:1200px){ #app-shell { padding:0 1rem 2rem; } }
  @media (max-width:800px){ #app-shell { padding:0 0.6rem 2rem; } }
  /* Roadmap now lives outside #app-shell; prevent unintended horizontal scroll container */
  #app-shell #roadmap-flex { overflow-x:visible; }
    
    body.center-domains #roadmap {
      justify-content: center; /* Override to center */
    }


    /* Domain Container Styles */
    
    /* Base domain container - structural styles */
    .domain-container {
      position: relative;
      display: grid;
      grid-template-rows: repeat(28, 1.5vmax);
      gap: 0.1vmax;
      width: max-content;
      padding: 0.05vmax 0.2vmax 0.2vmax 0.2vmax;
    }

    /* Standard domain visual styles */
    .domain-container:not(.domain-SKL) {
      background: white;
      border: 2px solid;
      border-radius: 0.25vmax;
    }

    /* Skill domain specific styles */
    .domain-SKL.domain-container {
      background: transparent;
      border: none;
      padding: 0.02vmax 0.05vmax 0.08vmax 0.05vmax; /* tighter padding */
    }

    .domain-unit {
      display: flex; /* New addition */
      flex-direction: column; /* Stack items vertically */
      width: min-content; /* Shrink to fit content */
      align-items: center; /* Center items horizontally */
      gap: 0.1vmax; /* Space between items */
      flex: 0 0 auto; /* Prevent shrinking */
      margin: 0; /* No margin to prevent shifting */
      padding: 0; /* No padding to prevent shifting */
      min-width: 0; /* Prevent overflow */
      max-width: none; /* Prevent overflow */
    }

    /* Base domain title - structural styles */
    .domain-title {
      position: relative;
      z-index: 3;
      width: 100%;
      box-sizing: border-box;
      text-align: center;
      font-weight: 500;
      font-size: 0.8vmax;
      padding: 0.2vmax 0;
      max-width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      height: var(--domain-title-height);
      margin: 0;
      line-height: 1;
      border: 2px solid;         /* Default border for all domain titles */
      border-radius: 0.25vmax;
    }

    /* Ensure skill domain title has no border even though it is not a descendant of .domain-SKL container */
    .domain-title.domain-SKL { /* Domain class is added directly to the title element in JS */
      border: none;
    }

    /* Skill domain title styles - removes border */
    .domain-SKL .domain-title {
      border: none;
      background: none;
      color: transparent;
    }

    .domain-wrapper { /* Wrapper for domain title + domain container */
      display: grid;            /* Grid for title + domain container */
      grid-template-rows: auto 1fr; /* Title row on top, domain container below */
      width: max-content;           /* Shrinks to fit the domain */
      margin: 0;                   /* No margin to prevent shifting */
      padding: 0;                  /* No padding to prevent shifting */
    }
    
    .subdomain-container {     /* Container for each subdomain within a domain */
      position: relative;             /* Enables absolute positioning for title */
      padding-top: 1vmax;             /* Reserve space for overlay title */
      padding: 0.1vmax 0.1vmax 0.1vmax 0.1vmax;
      display: grid;
      grid-template-rows: repeat(28, 1.5vmax); /* Only rows for cert tiles */
      grid-auto-rows: 1.5vmax;
      gap: 0.1vmax;
      border-radius: 0.25vmax;
      justify-content: center;
      border: none;
    }
        
    .subdomain-canvas {          /* Background "canvas" for subdomain */
      border-radius: 0.25vmax;
      z-index: 0;              /* Keep behind tiles and labels */
      pointer-events: none;
      position: absolute;      /* Better isolation from layout flow */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .subdomain-title {          /* small title at the top of the subdomain canvas */
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1vmax;
      text-align: center;
      font-size: 0.6vmax;
      font-weight: 500;
      padding-top: 0.1vmax;
      pointer-events: none;
      white-space: normal;
      word-break: break-word;
      overflow-wrap: break-word;
      z-index: 2;
    }

    .cert-tile {                  /* Individual certification tile */
      width: 2.3vmax;
      height: 1.5vmax;
      display: flex;
      align-items: center;        /* vertically center content *inside* the tile */
      justify-content: center;    /* horizontally center content *inside* the tile */
      justify-self: center;    /* horizontally center the tile in its column */
      align-self: center;        /* center tile vertically in its grid row */
      text-align: center;
      font-size: 0.6vmax;
      font-weight: 400;
      border-radius: 0.25vmax;
      background-color: inherit;  /* Inherit from parent */
      border: 1px solid;          /* Use inherited border-color */
      color: white;               /* Set text color explicitly */
      padding: 0.2vmax;
      box-sizing: border-box;
      margin: 0;
      text-decoration: none;
    }

    /* Skill domain specific subdomain title styling */
    .domain-SKL .subdomain-title {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) rotate(270deg);
      transform-origin: center;
      white-space: nowrap;
      padding: 0.4vmax;
      font-size: 0.9vmax;
      font-weight: bold;
      background-color: transparent;
      color: var(--color-black-dark);
      width: auto;
      text-align: center;
      z-index: 1;
    }

    /* .skill-tile — Atomic visual unit for skill strata placement */
    /* Mirrors .cert-tile in layout, with half width for vertical labeling */
    .skill-tile {                  /* Skill tile for skill column */
      width: 0.6vmax;              /* Narrowed per user request (was 1.15vmax) */
      height: 1.5vmax;             /* Match tile row height */
      display: flex;
      align-items: center;         /* Vertically center label inside tile */
      justify-content: center;     /* Horizontally center label inside tile */
      justify-self: center;        /* Center the tile inside the grid cell */
      align-self: center;          /* Vertically center the tile inside its row */
      text-align: center;
      font-size: 0.6vmax;
      font-weight: 400;
      border-radius: 0.25vmax;     /* Match .cert-tile curvature */
      background-color: var(--color-black-light); /* Temporary neutral background */
      border: 1px solid var(--color-black-dark);  /* Darker contrast border */
      color: white;
      padding: 0.2vmax;            /* Slightly tighter padding for narrow label */
      box-sizing: border-box;
      margin: 0;
      text-decoration: none;
      pointer-events: none;                    /* Not interactive for now */
    }

    /* For all domain titles */
    .domain-title {
      background-color: transparent; /* Fallback if no domain-specific color */
    }

    /* For RSK domain specifically */
    .domain-RSK .domain-title {
      background-color: var(--domain-rsk-light) !important;
      color: var(--domain-rsk-dark) !important;
    }

    /* Lock it down in dark mode as well */
    body.dark-mode .domain-RSK .domain-title {
      background-color: var(--domain-rsk-light) !important;
      color: var(--domain-rsk-dark) !important;
    }
    
   /*
   // ======================================================
   // TEMPORARY DEBUG VISUAL BORDERS — FOR ALIGNMENT TESTING
   // ======================================================
   */


   /*
   // ======================================================
   // END GRID DEBUG MODE
   // ======================================================
   */

    
  </style>
</head>
<link rel="icon" href="data:,"> <!-- Prevents favicon request -->
<body>
<!-- Filter Control Panel -->


<!-- Dark Mode checkbox removed; now part of Display Mode pill group -->


<!-- Vendor filter moved into collapsible stack -->

<!-- Layout Constraining Wrapper -->
<div id="app-shell">
  <!-- Learner Mode Collapsible Stack -->
  <div id="learner-stack" class="filter-stack">
  <div class="filter-stack-header" id="learner-stack-toggle" role="button" tabindex="0" aria-expanded="true" aria-controls="learner-stack-lines">
    <span class="filter-stack-arrow" id="learner-stack-arrow">▾</span>
    <span class="filter-stack-title">Options</span>
  </div>
  <div id="learner-stack-lines">
    <div class="filter-line" style="align-items:center;">
      <span class="filter-label">Display Mode:</span>
      <div id="mode-pills" class="mode-filter-bar" aria-label="Display Mode"></div>
    </div>
    <div class="filter-line" style="align-items:center;">
      <span class="filter-label">Learner Mode:</span>
      <div id="learner-mode-pills" class="mode-filter-bar" aria-label="Learner Mode Toggle"></div>
    </div>
    <div class="filter-line" style="align-items:center;">
      <span class="filter-label">Learner Views:</span>
      <div id="learner-action-pills" class="mode-filter-bar" aria-label="Learner Actions"></div>
    </div>
  </div>
  </div>
  <!-- Domain / Skill / Mode Filters (stacked rows, collapsible) -->
  <div id="filters-secondary" class="filter-stack">
  <div class="filter-stack-header" id="filter-stack-toggle" role="button" tabindex="0" aria-expanded="true" aria-controls="filter-stack-lines">
    <span class="filter-stack-arrow" id="filter-stack-arrow">▾</span>
    <span class="filter-stack-title">Filters</span>
  </div>
  <div id="filter-stack-lines">
    <div class="filter-line">
      <span class="filter-label">Vendor:</span>
  <label class="vendor-filter-wrapper">
        <select id="vendor-filter" style="font-size:0.9vmax; padding:0.18vmax 0.5vmax; border-radius:0.5vmax;">
          <option value="__ALL__">All Vendors</option>
        </select>
      </label>
    </div>
    <div class="filter-line">
      <span class="filter-label">Domain Filter:</span>
      <div id="domain-checkboxes" class="domain-filter-bar"></div>
    </div>
    <div class="filter-line">
      <span class="filter-label">Skill Level:</span>
      <div id="strata-pills" class="strata-filter-bar" aria-label="Skill Level Toggles"></div>
    </div>
  </div>
  </div>
  <h1>Security Certification Roadmap</h1>
  <!-- End of constrained header/filter region -->
</div> <!-- /#app-shell -->

<!-- Roadmap placed outside #app-shell to avoid width clipping -->
<div id="roadmap-flex">
  <div id="roadmap-wrapper">
    <div id="roadmap"></div>
  </div>
</div>
<!-- Spacer below roadmap -->
<div style="height: 2vmax;"></div>


<script>


// =============================================================================
// RESERVED FOR TEMPORARY DEBUGGING /* Remove before production deployment */
// =============================================================================



// =============================================================================
// RESERVED FOR TEMPORARY DEBUGGING /* Remove before production deployment */
// =============================================================================


// Control flag for cross-cert functionality
const CROSS_CERT_MODE_ENABLED = false;
// Temporary test flag: disables home/guest bias logic so we can observe pure center-out placement
// without refactoring larger structural code. When true:
//  - Home certs with crossDomains no longer force left/center/right; they use center-out sequence
//  - Guest certs ignore proximity bias helpers and also use center-out sequence
//  - Bias helper functions remain defined but are unused (left in place for easy revert)
const DISABLE_HOME_GUEST_BIAS_TEST = true;

// ==============================
// Planned Certifications Limit (focus enforcement)
// ==============================
const MAX_PLANNED_CERTS = 5; // Hard cap for planned focus
const LEARNER_PLANNED_ORDER_KEY = 'learnerPlannedOrder.v1'; // Persist insertion order

function loadPlannedOrder(){
  try { const raw = localStorage.getItem(LEARNER_PLANNED_ORDER_KEY); if(!raw) return []; const arr = JSON.parse(raw); return Array.isArray(arr)?arr:[]; } catch(e){ console.warn('Could not load planned order', e); return []; }
}
function savePlannedOrder(){
  try { localStorage.setItem(LEARNER_PLANNED_ORDER_KEY, JSON.stringify(window.learnerPlannedOrder||[])); } catch(e){ console.warn('Could not save planned order', e); }
}
window.learnerPlannedOrder = loadPlannedOrder();

function addPlannedCertToOrder(certId){
  if(!window.learnerPlannedOrder.includes(certId)) { window.learnerPlannedOrder.push(certId); savePlannedOrder(); }
}
function removePlannedCertFromOrder(certId){
  const idx = window.learnerPlannedOrder.indexOf(certId);
  if(idx!==-1){ window.learnerPlannedOrder.splice(idx,1); savePlannedOrder(); }
}
function enforceLegacyPlannedLimit(){
  // Legacy reconciliation: ensures order list exists, aligns with current statuses, and trims overflow
  // Build list of currently planned from statuses
  const plannedIds = Object.entries(window.learnerCertStatuses||{}).filter(([,s])=>s==='planned').map(([id])=>id);
  // Ensure order array only references still-planned IDs
  window.learnerPlannedOrder = window.learnerPlannedOrder.filter(id=>plannedIds.includes(id));
  // Add any planned IDs missing from order (legacy) preserving discovery order
  plannedIds.forEach(id=>{ if(!window.learnerPlannedOrder.includes(id)) window.learnerPlannedOrder.push(id); });
  if(window.learnerPlannedOrder.length>MAX_PLANNED_CERTS){
    const toKeep = window.learnerPlannedOrder.slice(0,MAX_PLANNED_CERTS);
    const toDrop = window.learnerPlannedOrder.slice(MAX_PLANNED_CERTS);
    toDrop.forEach(id=>{ if(window.learnerCertStatuses[id]==='planned'){ delete window.learnerCertStatuses[id]; } });
    window.learnerPlannedOrder = toKeep;
    saveLearnerStatuses();
  }
  savePlannedOrder();
}

// Centralized filter state — controls what gets shown on the roadmap
    const filterState = {
      showCrossDomainCerts: false,
      showCrossSubdomainCerts: false,
      showOnlyCrossCerts: false,
      visibleDomains: [], // filled after loading domains.json
      visibleVendors: [], // filled after loading certs.json
      showAchieved: true,
      showPlanned: true,
      visibleSkillStrata: {
        beginner: true,
        intermediate: true,
        expert: true
      },
      darkMode: false,
      filtersExpanded: true,
      selectedVendorMode: '__ALL__', // tracks raw selection value for vendor dropdown
      learnerMode: false,
      learnerEdit: false,
      learnerStackExpanded: true,
      learnerView: 'all'
    };

    // When true, the roadmap keeps all skill strata row heights constant (no vertical compression)
    // so tiles retain their absolute vertical positioning numbers even when filters hide most tiles.
    // Set to false to restore previous behavior where unused rows collapse (causing upward shift).
    const PRESERVE_SKILL_ROW_LAYOUT = true;

    // ================================
    // Persistence Utilities (localStorage)
    // ================================
  /*
   * PERSISTENCE OVERVIEW
   * --------------------------------------------------
   * We persist a subset of the user's UI preferences and filter selections
   * in localStorage so that returning sessions reopen with the same view.
   * This is a lightweight, client-only approach intended as a stepping stone
   * toward a future authenticated profile (OAuth or similar) where this
   * state would instead round-trip to a backend service.
   *
   * VERSIONING
   * The STORAGE_KEY includes a semantic suffix ("v1"). Increment this when
   * the shape of the stored snapshot changes incompatibly (e.g., rename keys,
   * remove fields, or change types). For additive changes (adding new keys),
   * you generally DO NOT need to bump the version—just supply defaults and
   * merge new values on load. For breaking changes, bump to v2 and optionally
   * implement a one-time migration reading the old key.
   *
   * WHAT WE STORE NOW
   *  - visibleDomains: [String] domain IDs the user has left checked
   *  - visibleVendorIds: [String] vendor IDs actively included (redundant but
   *    kept for explicitness; can be recomputed but storing simplifies future diffs)
   *  - selectedVendorMode: '__ALL__' | '__NONE__' | vendorId (raw dropdown value)
   *  - darkMode: Boolean
   *  - visibleSkillStrata: { beginner, intermediate, expert } (future-proof)
   *
   * FIELDS TO ADD LATER (GUIDANCE)
   *  - compressSkillRows (Boolean)
   *  - showCrossDomainCerts / showCrossSubdomainCerts / showOnlyCrossCerts
   *  - userSortPreference (if manual reordering is introduced)
   *  - layoutVersion (if tile sizing changes and you need migrations)
   *
   * ADDING A NEW FIELD
   * 1. Add default to filterState.
   * 2. Include in saveState() snapshot.
   * 3. Merge in applyPersistedState() if present.
   * 4. Trigger saveStateDebounced() whenever it changes.
   *
   * MIGRATION STRATEGY (WHEN MOVING TO SERVER PROFILES)
   *  - Encapsulate save/load behind an abstraction (e.g., persistence.get() / set()).
   *  - Replace localStorage calls with fetch/POST once auth is active.
   *  - Maintain localStorage as an offline cache fallback until confidence.
   *  - Introduce a 'lastUpdated' timestamp to support conflict resolution.
   *
   * PRIVACY NOTE
   * Only non-sensitive UI preference data is stored. Do NOT persist secrets
   * or PII here. Future authenticated sync should still treat these fields as
   * user-owned preferences.
   *
   * ERROR HANDLING
   * All reads/writes wrapped in try/catch. Failures degrade gracefully with
   * console warnings. If storage quota is exceeded, user simply loses persistence.
   *
   * RESET INSTRUCTIONS
   *   localStorage.removeItem('roadmapState.v1');
   * or programmatically call a future resetPreferences() helper.
   *
   * PERFORMANCE
   * Saves are debounced (300ms) to prevent thrashing; snapshot is small.
   *
   * TESTING / VERIFICATION STEPS
   *  - Change vendor filter, toggle dark mode, uncheck a domain → refresh → state persists.
   *  - Corrupt the stored JSON manually → load should warn and ignore.
   */
    const STORAGE_KEY = 'roadmapState.v1'; // increment suffix if structure changes
  const LEARNER_STATE_KEY = 'learnerCertStatuses.v1';

    function saveState() {
      try {
        const snapshot = {
          visibleDomains: filterState.visibleDomains,
          visibleVendorIds: filterState.visibleVendorIds,
          selectedVendorMode: filterState.selectedVendorMode,
          darkMode: filterState.darkMode,
          visibleSkillStrata: filterState.visibleSkillStrata,
          filtersExpanded: filterState.filtersExpanded
          , learnerMode: filterState.learnerMode
          , learnerEdit: filterState.learnerEdit
          , learnerStackExpanded: filterState.learnerStackExpanded
          , learnerView: filterState.learnerView
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
      } catch (e) {
        console.warn('Could not save roadmap state:', e);
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) {
        console.warn('Could not load roadmap state:', e);
        return null;
      }
    }

    // Debounce helper to avoid excessive writes
    function debounce(fn, delay=250) {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), delay); };
    }
    const saveStateDebounced = debounce(saveState, 300);

    function applyPersistedState(persisted, domains, normalizedVendors) {
      if (!persisted) return;

      // Domains: only keep those that still exist
      if (Array.isArray(persisted.visibleDomains)) {
        const domainSet = new Set(domains.map(d=>d.domainId));
        filterState.visibleDomains = persisted.visibleDomains.filter(d=>domainSet.has(d));
      }

      // Vendors
      if (Array.isArray(persisted.visibleVendorIds)) {
        filterState.visibleVendorIds = persisted.visibleVendorIds.filter(v=>normalizedVendors.some(n=>n.vendorId===v));
      }
      if (persisted.selectedVendorMode) {
        filterState.selectedVendorMode = persisted.selectedVendorMode;
      }

      // Dark mode
      if (typeof persisted.darkMode === 'boolean') {
        filterState.darkMode = persisted.darkMode;
        document.body.classList.toggle('dark-mode', filterState.darkMode);
        const dmToggle = document.getElementById('dark-mode-checkbox');
        if (dmToggle) dmToggle.checked = filterState.darkMode;
      }

      // Skill strata visibility (future-proof if you add toggles)
      if (persisted.visibleSkillStrata) {
        filterState.visibleSkillStrata = { ...filterState.visibleSkillStrata, ...persisted.visibleSkillStrata };
      }
      if (typeof persisted.filtersExpanded === 'boolean') {
        filterState.filtersExpanded = persisted.filtersExpanded;
      }
      if (typeof persisted.learnerMode === 'boolean') {
        filterState.learnerMode = persisted.learnerMode;
      }
      if (typeof persisted.learnerEdit === 'boolean') {
        filterState.learnerEdit = persisted.learnerEdit;
      }
      if (typeof persisted.learnerStackExpanded === 'boolean') {
        filterState.learnerStackExpanded = persisted.learnerStackExpanded;
      }
      if (typeof persisted.learnerView === 'string') {
        filterState.learnerView = persisted.learnerView;
      }
    }

    function loadLearnerStatuses(){
      try { const raw = localStorage.getItem(LEARNER_STATE_KEY); if(!raw) return {}; return JSON.parse(raw); } catch(e){ console.warn('Could not load learner statuses:', e); return {}; }
    }
    function saveLearnerStatuses(){
      try { localStorage.setItem(LEARNER_STATE_KEY, JSON.stringify(window.learnerCertStatuses)); } catch(e){ console.warn('Could not save learner statuses:', e); }
    }
    window.learnerCertStatuses = loadLearnerStatuses();

    //
    function getVisibleSkillRowCount(skillStrataList, filterState) {
      let totalRows = 1; // row 1 is always the heading row
      for (const level of skillStrataList) {
        if (filterState.visibleSkillStrata[level.id]) {
          totalRows += (level.end - level.start + 1);
        }
      }
      return totalRows;
    }

    function getSkillLevelFromStrata(strataNumber, skillStrataList) {
      for (const level of skillStrataList) {
        if (strataNumber >= level.start && strataNumber <= level.end) {
          return level.id;
        }
      }
      return null;
    }

    async function loadJSON(path) {
      const res = await fetch(path);
      return res.json();
    }

    function applyGridSpanStyles(element) {
      const colStart = element.getAttribute('data-grid-column-start');
      const colSpan = element.getAttribute('data-grid-column-span');

      if (colStart && colSpan) {
        element.style.setProperty('--col-start', colStart);
        element.style.setProperty('--col-span', colSpan);
      }
    }

    function usedSkillRowsHasRowsInRange(start, end, usedSkillRows) {
      for (let i = start; i <= end; i++) {
        if (usedSkillRows.has(i)) return true;
      }
      return false;
    }

    function getCenterOutwardColumnOrder(span) {
      const center = Math.ceil(span / 2);
      const order = [center];

      for (let offset = 1; order.length < span; offset++) {
        if (center + offset <= span) order.push(center + offset);
        if (center - offset >= 1) order.push(center - offset);
      }

      return order;
    }

    function getBiasDirection(cert, renderedDomain, allDomains) {
      const homeDomainId = cert.domainId;
      const renderedDomainId = renderedDomain.domainId;

      if (renderedDomainId === homeDomainId && !cert.crossDomains?.length) {
        return 0; // No guests, neutral
      }

      const home = allDomains.find(d => d.domainId === homeDomainId);
      const guest = allDomains.find(d => d.domainId === renderedDomainId);

      if (!home || !guest) return 0;

      const homePos = home.domainDisplayOrder;

      if (renderedDomainId !== homeDomainId) {
        // Guest tile
        const guestPos = guest.domainDisplayOrder;
        if (guestPos < homePos) return -1; // Guest is left of home
        if (guestPos > homePos) return 1;  // Guest is right of home
        return 0;
      }

      // Home tile with guests — check if guests are left, right, or both
      const guestPositions = cert.crossDomains
        .map(g => allDomains.find(d => d.domainId === g)?.domainDisplayOrder)
        .filter(pos => pos !== undefined);

      const hasLeft = guestPositions.some(pos => pos < homePos);
      const hasRight = guestPositions.some(pos => pos > homePos);

      if (hasLeft && hasRight) return 99;  // Guests on both sides
      if (hasLeft) return -1;
      if (hasRight) return 1;

      return 0;
    }

    function getColumnOrderWithProximityBias(cert, renderedDomain, sub, allDomains) {
      const span = sub.gridColumnSpan;
      const center = Math.ceil(span / 2);
      const order = [];
      const direction = getBiasDirection(cert, renderedDomain, allDomains);

      if (direction === -1) {
        // Bias left
        for (let col = span; col >= 1; col--) {
          order.push(col);
        }
      } else if (direction === 1) {
        // Bias right
        for (let col = 1; col <= span; col++) {
          order.push(col);
        }
      } else if (direction === 99) {
        // Guests on both sides → center-first
        order.push(center);
        for (let offset = 1; order.length < span; offset++) {
          if (center - offset >= 1) order.push(center - offset);
          if (center + offset <= span) order.push(center + offset);
        }
      } else {
        // Neutral fallback
        return getCenterOutwardColumnOrder(span);
      }

      return order;
    }

    function getColumnOrderWithBias(cert, renderedDomain, sub, allDomains) {
      const span = sub.gridColumnSpan;
      const homeDomainId = cert.domainId;
      const renderedDomainId = renderedDomain.domainId;

      // Neutral center-out fallback
      const center = Math.ceil(span / 2);
      const order = [center];

      // Determine bias direction:
      let biasDirection = 0; // 0=centered, -1=left, +1=right

      if (renderedDomainId !== homeDomainId) {
        // Guest cert
        const home = allDomains.find(d => d.domainId === homeDomainId);
        const guest = allDomains.find(d => d.domainId === renderedDomainId);
        if (home && guest) {
          if (home.domainDisplayOrder < guest.domainDisplayOrder) {
            biasDirection = -1; // home is left of guest → bias left
          } else if (home.domainDisplayOrder > guest.domainDisplayOrder) {
            biasDirection = 1; // home is right of guest → bias right
          }
        }
      } else if (cert.crossDomains?.length) {
        // Home cert with guests → find average guest position
        const guestPositions = cert.crossDomains
          .map(g => allDomains.find(d => d.domainId === g))
          .filter(Boolean)
          .map(d => d.domainDisplayOrder);
        const homePos = renderedDomain.domainDisplayOrder;
        if (guestPositions.length) {
          const avgGuest = guestPositions.reduce((a, b) => a + b, 0) / guestPositions.length;
          if (avgGuest < homePos) biasDirection = -1;
          else if (avgGuest > homePos) biasDirection = 1;
        }
      }

      // Build fill order based on bias direction
      for (let offset = 1; order.length < span; offset++) {
        const right = center + offset;
        const left = center - offset;

        if (biasDirection === -1) {
          if (left >= 1) order.push(left);
          if (right <= span) order.push(right);
        } else if (biasDirection === 1) {
          if (right <= span) order.push(right);
          if (left >= 1) order.push(left);
        } else {
          if (left >= 1) order.push(left);
          if (right <= span) order.push(right);
        }
      }

      return order;
    }

    /**
     * Draws the roadmap with domains, subdomains, certifications, and skill strata.
     * @param {Array} domains - List of domain objects.
     * @param {Array} subdomains - List of subdomain objects.
     * @param {Array} certs - List of certification objects.
     * @param {Array} skillStrata - List of skill strata objects.
     */
    function buildSkillStrataRail(skillStrata) {
      const rail = document.getElementById('skill-strata-rail');
      if (!rail) return;
      rail.innerHTML = '';
  const totalRows = 28; // could derive dynamically later
  rail.style.minHeight = `calc(var(--skill-rail-top-offset) + ${totalRows} * var(--skill-row-height))`;
  const topOffset = getComputedStyle(document.documentElement).getPropertyValue('--skill-rail-top-offset').trim() || '0px';
      skillStrata.forEach(level => {
        const seg = document.createElement('div');
        seg.className = `skill-strata-segment strata-${level.id}`;
        seg.setAttribute('data-strata-id', level.id);
        const label = document.createElement('span');
        label.className = 'strata-label';
        label.textContent = level.label.toUpperCase();
        seg.appendChild(label);
        const rowSpan = (level.end - level.start + 1);
  seg.style.top = `calc(${topOffset} + (${level.start - 1} * var(--skill-row-height)))`;
        seg.style.height = `calc(${rowSpan} * var(--skill-row-height))`;
        rail.appendChild(seg);
      });
      updateStrataRailVisibility();
    }

    /**
     * Global calibration: derive a single baseline top and uniform row height
     * from currently rendered cert tiles, then place EVERY strata segment from
     * that math. This keeps alignment stable even when an entire level is
     * filtered (dimmed) and its tiles are absent.
     * Strategy:
     *  1. Collect all cert tiles having data-skill-row.
     *  2. Build ordered list of distinct row indices present.
     *  3. Compute rowHeight as the median delta between consecutive row tops (robust vs. outliers).
     *  4. Use the smallest observed row as baselineRow with its top offset.
     *  5. For each segment (level.start..level.end) set:
     *       top = baselineTop + (level.start - baselineRow) * rowHeight
     *       height = (rowSpan) * rowHeight
     *  6. Fallback: if fewer than 2 rows measurable, skip (CSS calc() stays).
     */
    function calibrateSkillStrataSegments(skillStrata) {
      const rail = document.getElementById('skill-strata-rail');
      if (!rail) return;
      const railRect = rail.getBoundingClientRect();
      const tiles = Array.from(document.querySelectorAll('.cert-tile[data-skill-row]'));
      if (tiles.length === 0) return; // nothing to measure

      // Map row -> first tile element
      const rowMap = new Map();
      tiles.forEach(t => {
        const row = parseInt(t.getAttribute('data-skill-row'), 10);
        if (!rowMap.has(row)) rowMap.set(row, t);
      });
      const measuredRows = Array.from(rowMap.keys()).sort((a,b)=>a-b);
      if (measuredRows.length < 2) return; // need at least two for a delta

      // Collect top positions
      const rowTops = measuredRows.map(r => ({
        row: r,
        top: rowMap.get(r).getBoundingClientRect().top
      }));
      // Compute deltas between consecutive rows
      const deltas = [];
      for (let i=1;i<rowTops.length;i++) {
        const d = rowTops[i].top - rowTops[i-1].top;
        if (d>0) deltas.push(d);
      }
      if (!deltas.length) return;
      // Median delta for robustness
      deltas.sort((a,b)=>a-b);
      const mid = Math.floor(deltas.length/2);
      const rowHeightPx = deltas.length % 2 ? deltas[mid] : (deltas[mid-1]+deltas[mid])/2;

      const baselineRow = rowTops[0].row;
      const baselineTopPx = rowTops[0].top - railRect.top; // relative to rail

      skillStrata.forEach(level => {
        const seg = rail.querySelector(`.skill-strata-segment.strata-${level.id}`);
        if (!seg) return;
        const rowSpan = level.end - level.start + 1;
        const topPx = baselineTopPx + (level.start - baselineRow) * rowHeightPx;
        const heightPx = rowSpan * rowHeightPx;
        if (heightPx > 0) {
          seg.style.top = `${topPx}px`;
          seg.style.height = `${heightPx}px`;
          seg.classList.add('is-calibrated');
        }
      });
    }

    function updateStrataRailVisibility() {
      const rail = document.getElementById('skill-strata-rail');
      if (!rail) return;
      rail.querySelectorAll('.skill-strata-segment').forEach(seg => {
        const id = seg.getAttribute('data-strata-id');
        if (!filterState.visibleSkillStrata[id]) seg.classList.add('is-dimmed');
        else seg.classList.remove('is-dimmed');
      });
    }

    function drawRoadmap(domains, subdomains, certs, skillStrata) {

      const roadmapEl = document.getElementById('roadmap');
      // Ensure rail placeholder exists at start
      let rail = document.getElementById('skill-strata-rail');
      if (!rail) {
        rail = document.createElement('div');
        rail.id = 'skill-strata-rail';
        rail.setAttribute('role','img');
        rail.setAttribute('aria-label','Skill levels: Expert, Intermediate, Beginner');
      }
      // Always (re)insert rail as first child
      if (roadmapEl.firstChild !== rail) {
        roadmapEl.insertBefore(rail, roadmapEl.firstChild);
      }
      let gridRowsTemplate;

      if (PRESERVE_SKILL_ROW_LAYOUT) {
        // Keep a fixed height for all 28 rows so row indices remain visually stable.
        gridRowsTemplate = 'repeat(28, 1.5vmax)';
      } else {
        // Previous behavior: collapse unused rows to 0 height (causes vertical shifting on filter changes).
        const usedSkillRows = new Set();
        certs.forEach(cert => {
          const certLevel = getSkillLevelFromStrata(cert.certSkillStrata, skillStrata);
            if (!filterState.visibleSkillStrata[certLevel]) return;
            if (!filterState.visibleVendorIds.includes(cert.vendorId)) return;
            usedSkillRows.add(cert.certSkillStrata);
        });
        let prunedGridRows = '';
        skillStrata.forEach(level => {
          for (let row = level.start; row <= level.end; row++) {
            prunedGridRows += usedSkillRows.has(row) ? '1.5vmax ' : '0 ';
          }
        });
        gridRowsTemplate = prunedGridRows.trim();
      }

      
        /*
        // This canvas layer is currently inert and not used visually,
        // Visual canvas layer
        const canvas = document.createElement("div");
        canvas.className = `subskill-canvas ${levelId}`;
        canvas.style.backgroundColor = `var(${level.color})`;
        canvas.style.height = "100%";
        canvas.style.width = "100%";
        canvas.style.position = "relative";
        canvas.style.pointerEvents = "none";
        canvas.style.borderRadius = "0.25vmax";
        */

      buildSkillStrataRail(skillStrata);

      domains
        .filter(domain => domain.domainId !== 'SKL')
        .filter(domain => filterState.visibleDomains.includes(domain.domainId))
        .forEach(domain => {
        const domainDiv = document.createElement('div');
        domainDiv.classList.add('domain-container', `domain-${domain.domainId}`);
  // Use unified grid row template (either fixed or pruned based on flag)
  domainDiv.style.gridTemplateRows = gridRowsTemplate;
        domainDiv.style.borderColor = `var(--domain-${domain.domainId.toLowerCase()}-dark)`;

        // Dynamically set how wide the domain container should be
        const allContainers = subdomains.filter(sd => sd.domainId === domain.domainId);

        let maxColumn = 0;
        allContainers.forEach(c => {
          const endCol = c.gridColumnStart + c.gridColumnSpan - 1;
          if (endCol > maxColumn) maxColumn = endCol;
        });

        domainDiv.style.gridTemplateColumns = `repeat(${maxColumn}, 2.3vmax)`;

      const domainSubdomains = subdomains.filter(sd => sd.domainId === domain.domainId);
      domainSubdomains.forEach(sub => {

        // Subdomain container
        const subDiv = document.createElement('div');
        subDiv.classList.add('subdomain-container', `subdomain-${sub.subdomainId}`);

        subDiv.style.gridTemplateColumns = `repeat(${sub.gridColumnSpan}, 2.3vmax)`;
  subDiv.style.gridTemplateRows = gridRowsTemplate;

        subDiv.style.gridColumnStart = sub.gridColumnStart;
        subDiv.style.gridColumnEnd = `span ${sub.gridColumnSpan}`;
        subDiv.style.gridRowStart = sub.gridRowStart;
        subDiv.style.gridRowEnd = `span ${sub.gridRowSpan}`;

        // Subdomain canvas (visual layer behind container)
        const canvas = document.createElement('div');
        canvas.classList.add('subdomain-canvas');
        canvas.setAttribute('data-subdomain-id', sub.subdomainId);

        // positioning based on grid math
        canvas.style.gridRowStart = sub.gridRowStart;
        canvas.style.gridRowEnd = `span ${sub.gridRowSpan}`;
        canvas.style.gridColumnStart = sub.gridColumnStart;
        canvas.style.gridColumnEnd = `span ${sub.gridColumnSpan}`;

        canvas.style.position = 'relative';
        canvas.style.zIndex = 0;
        canvas.style.pointerEvents = 'none';
        canvas.style.backgroundColor = sub.subdomainId.endsWith('_unspec')
          ? 'transparent'
          : `var(${sub.subdomainColor || '--domain-default-white'})`;
        
                
        // Subdomain title overlay (only if not an unspecialized container)
        if (!sub.subdomainId.endsWith('_unspec')) {
          const titleOverlay = document.createElement('div');
          titleOverlay.className = 'subdomain-title';
          titleOverlay.textContent = sub.subdomainShortName;
          subDiv.appendChild(titleOverlay);
        }

        domainDiv.appendChild(canvas); // Must go before the subdomain container

        // Add cert tiles
        const subCerts = certs.filter(cert => {
          if (filterState.showOnlyCrossCerts) {
            const isCrossDomain = Array.isArray(cert.crossDomains) && cert.crossDomains.length > 0;
            const isCrossSub = Array.isArray(cert.crossSubdomains) && cert.crossSubdomains.length > 0;
            if (!isCrossDomain && !isCrossSub) return false;
          }

          // Case 1: Cert belongs to this exact subdomain
          const isDirectMatch = cert.subdomainId === sub.subdomainId;

          // Case 2: Cross-subdomain guest
          const isCrossSub = cert.crossSubdomains?.includes(sub.subdomainId);
          const showCrossSub = filterState.showCrossSubdomainCerts;

          // Case 3: Cross-domain guest logic
          const isCrossDomainGuest = cert.crossDomains?.includes(domain.domainId);
          const showCrossDomain = filterState.showCrossDomainCerts;

          // Case 4: RSK guest logic - to preserve left/right visual
          const isRSK = domain.domainId === "RSK";
          let isValidRSKGuest = false;

          if (isCrossDomainGuest && isRSK) {
            const originDomain = domains.find(d => d.domainId === cert.domainId);
            const rskDomain = domains.find(d => d.domainId === "RSK");

            if (originDomain && rskDomain) {
              const originOrder = originDomain.domainDisplayOrder;
              const rskOrder = rskDomain.domainDisplayOrder;
              const expectedSubdomain =
                originOrder < rskOrder ? "RSK_left_unspec" : "RSK_right_unspec";

              isValidRSKGuest = sub.subdomainId === expectedSubdomain;
            }
          }

          // Final return condition
          return (
            isDirectMatch ||
            (isCrossSub && showCrossSub) ||
            ((isCrossDomainGuest && showCrossDomain) && (
              (domain.domainId !== "RSK" && sub.subdomainId === `${domain.domainId}_unspec`) ||
              isValidRSKGuest
            ))
          );
        });

        // Skip rendering this subdomain if it has no visible certs
        const visibleSubCerts = subCerts.filter(cert => {
          const level = getSkillLevelFromStrata(cert.certSkillStrata, skillStrata);
          return filterState.visibleSkillStrata[level] &&
                filterState.visibleVendorIds.includes(cert.vendorId);
        });

        if (visibleSubCerts.length === 0) return;

        const tileRowMap = {}; // { skillRow: currentTileIndex or placement cache }
        const occupiedCells = {}; // key = `${row}-${col}`, value = true if taken
        const columnOrders = {}; // { skillRow: [col1, col2, ...] }

        // 🔹 Home certs are rendered first to claim their preferred spots
        subCerts.filter(c => c.domainId === domain.domainId).forEach(cert => {
          const certLevel = getSkillLevelFromStrata(cert.certSkillStrata, skillStrata);
          if (!filterState.visibleSkillStrata[certLevel]) return;
          if (!filterState.visibleVendorIds.includes(cert.vendorId)) return;

          const tile = makeCertTile(cert, domains, domain.domainId, sub.subdomainId);
          const skillRow = cert.certSkillStrata;

          let colStart;

          // 🔹 Determine column placement
          // Bias removed when DISABLE_HOME_GUEST_BIAS_TEST === true
          if (!DISABLE_HOME_GUEST_BIAS_TEST && cert.crossDomains?.length) {
            // (Original biased placement kept for quick toggle testing)
            const guestOrders = cert.crossDomains
              .map(gid => domains.find(d => d.domainId === gid)?.domainDisplayOrder)
              .filter(pos => pos !== undefined);
            const homeOrder = domain.domainDisplayOrder;
            const hasLeft = guestOrders.some(pos => pos < homeOrder);
            const hasRight = guestOrders.some(pos => pos > homeOrder);
            if (hasLeft && hasRight) colStart = Math.ceil(sub.gridColumnSpan / 2);
            else if (hasLeft) colStart = 1;
            else if (hasRight) colStart = sub.gridColumnSpan;
            else colStart = Math.ceil(sub.gridColumnSpan / 2);
          } else {
            // Unified center-out placement with occupancy awareness
            if (!tileRowMap[skillRow]) {
              tileRowMap[skillRow] = 0;
              columnOrders[skillRow] = getCenterOutwardColumnOrder(sub.gridColumnSpan);
            }
            const colIndex = tileRowMap[skillRow];
            colStart = columnOrders[skillRow][colIndex];
            tileRowMap[skillRow]++;
          }

          tile.style.gridRowStart = skillRow;
          tile.style.gridColumnStart = colStart;
          const finalKey = `${skillRow}-${colStart}`;
          tileRowMap[finalKey] = true;

          subDiv.appendChild(tile);
          applyLearnerStatusToTile(tile);
        });

        // 🔹 Guest certs rendered after home certs (yielding to occupied slots)
        subCerts
          .filter(c => c.domainId !== domain.domainId)
          .sort((a, b) => {
            // 1. Fewer cross-domain appearances gets priority
            const aCross = a.crossDomains?.length || 0;
            const bCross = b.crossDomains?.length || 0;
            if (aCross !== bCross) return aCross - bCross;

            // 2. Closer proximity to the current domain
            const aHome = domains.find(d => d.domainId === a.domainId);
            const bHome = domains.find(d => d.domainId === b.domainId);
            const guestOrder = domain.domainDisplayOrder;

            const aDist = aHome ? Math.abs(aHome.domainDisplayOrder - guestOrder) : Infinity;
            const bDist = bHome ? Math.abs(bHome.domainDisplayOrder - guestOrder) : Infinity;
            if (aDist !== bDist) return aDist - bDist;

            // 3. Subdomain proximity tie-breaker when domain proximity is equal
            const aSub = subdomains.find(s => s.subdomainId === a.subdomainId);
            const bSub = subdomains.find(s => s.subdomainId === b.subdomainId);
            if (aSub && bSub) {
              const aSubDist = Math.abs(aSub.gridColumnStart - sub.gridColumnStart);
              const bSubDist = Math.abs(bSub.gridColumnStart - sub.gridColumnStart);
              if (aSubDist !== bSubDist) return aSubDist - bSubDist;
            }

            // 4. Fallback: preserve original JSON order
            return 0;
          })
          
          .forEach(cert => {
          const certLevel = getSkillLevelFromStrata(cert.certSkillStrata, skillStrata);
          if (!filterState.visibleSkillStrata[certLevel]) return;
          if (!filterState.visibleVendorIds.includes(cert.vendorId)) return;

          const tile = makeCertTile(cert, domains, domain.domainId, sub.subdomainId);
          const skillRow = cert.certSkillStrata;

          const homeDomain = domains.find(d => d.domainId === cert.domainId);
          const guestDomain = domains.find(d => d.domainId === domain.domainId);

          if (!DISABLE_HOME_GUEST_BIAS_TEST && homeDomain && guestDomain) {
            // Original biased + proximity-first algorithm retained (not executed when test flag is true)
            const homeOrder = homeDomain.domainDisplayOrder;
            const guestOrder = guestDomain.domainDisplayOrder;
            const preferredCol = homeOrder < guestOrder ? 1 : sub.gridColumnSpan;
            const sameRowOrder = getColumnOrderWithProximityBias(cert, domain, sub, domains);
            for (const col of sameRowOrder) {
              const key = `${skillRow}-${col}`;
              if (!tileRowMap[key]) {
                tileRowMap[key] = true;
                tile.style.gridRowStart = skillRow;
                tile.style.gridColumnStart = col;
                subDiv.appendChild(tile);
                applyLearnerStatusToTile(tile);
                return;
              }
            }
            const maxRowOffset = 2;
            for (let offset = 0; offset <= maxRowOffset; offset++) {
              const candidateRows = [skillRow - offset, skillRow + offset];
              for (const row of candidateRows) {
                if (row < 1 || row > 28) continue;
                const key = `${row}-${preferredCol}`;
                if (!tileRowMap[key]) {
                  tileRowMap[key] = true;
                  tile.style.gridRowStart = row;
                  tile.style.gridColumnStart = preferredCol;
                  subDiv.appendChild(tile);
                  return;
                }
              }
            }
          }

          // Unified simple center-out placement (always used when test flag is true)
          if (!tileRowMap[skillRow]) {
            tileRowMap[skillRow] = 0;
            columnOrders[skillRow] = getCenterOutwardColumnOrder(sub.gridColumnSpan);
          }
          const colIndex = tileRowMap[skillRow];
          const chosenCol = columnOrders[skillRow][colIndex];
          tileRowMap[skillRow]++;
          const keyFinal = `${skillRow}-${chosenCol}`;
          tileRowMap[keyFinal] = true;
          tile.style.gridRowStart = skillRow;
          tile.style.gridColumnStart = chosenCol;
          subDiv.appendChild(tile);
          applyLearnerStatusToTile(tile);
        });

        domainDiv.appendChild(subDiv);
      });

      // Wrap domain content in a domain-wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'domain-wrapper';
      wrapper.appendChild(domainDiv);                     // Add the domain container
      // Create the domain title
      const domainTitle = document.createElement('div');
      domainTitle.className = 'domain-title';
  // Add domain class directly so domain-specific CSS (including SKL override) can target it
  domainTitle.classList.add(`domain-${domain.domainId}`);
      domainTitle.textContent = domain.domainShortName;
      domainTitle.style.color = `var(--domain-${domain.domainId.toLowerCase()}-dark)`;
      domainTitle.style.backgroundColor = `var(--domain-${domain.domainId.toLowerCase()}-light)`;
      domainTitle.style.textAlign = 'center';
      domainTitle.style.width = '100%';
      domainTitle.style.whiteSpace = 'normal';
      domainTitle.style.wordBreak = 'normal';
      domainTitle.style.overflowWrap = 'break-word';
      domainTitle.style.textOverflow = 'unset';
      domainTitle.style.overflow = 'visible';

      const domainUnit = document.createElement('div');
      domainUnit.className = 'domain-unit';
      domainUnit.style.gridColumnStart = domain.domainDisplayOrder + 1;
      domainUnit.appendChild(domainTitle);
      domainUnit.appendChild(wrapper);

      roadmapEl.appendChild(domainUnit);

      });
      // After all tiles are laid out, perform pixel alignment calibration
      requestAnimationFrame(() => calibrateSkillStrataSegments(skillStrata));
      requestAnimationFrame(()=>{ document.querySelectorAll('.cert-tile').forEach(applyLearnerStatusToTile); });
    }

    function makeCertTile(cert, domains, renderedDomainId, renderedSubdomainId) {
      const tile = document.createElement('a');
      tile.href = cert.certUrl;
      tile.target = '_blank';
      tile.className = 'cert-tile';
      tile.textContent = cert.certTileLabel;
      tile.title = cert.certTooltip;
      tile.setAttribute('data-cert-id', cert.certId);
      tile.setAttribute('data-domain-id', cert.domainId);
      if (cert.subdomainId) {
        tile.setAttribute('data-subdomain-id', cert.subdomainId);
      }
      // Add a stable data attribute for the skill row to support alignment calibration
      tile.setAttribute('data-skill-row', cert.certSkillStrata);

      tile.style.gridRowStart = cert.certSkillStrata;

      const domain = domains.find(d => d.domainId === cert.domainId);
      const teamRoles = domain.teamRoles || {};
      const role = cert.teamRole || "DefaultTeam";

      const domainIdLower = cert.domainId.toLowerCase();
      const isGuestInThisDomain = renderedDomainId !== cert.domainId;
      const isGuestInThisSubdomain = cert.crossSubdomains?.includes(renderedSubdomainId);
      const isGuest = isGuestInThisDomain || isGuestInThisSubdomain;

      if (teamRoles[role] && teamRoles[role].tileColor) {
        const colorVar = isGuest
          ? teamRoles[role].tileColorLight || teamRoles[role].tileColor
          : teamRoles[role].tileColor;
        const borderVar = teamRoles[role].borderColor || `--domain-${domainIdLower}-dark`;

        tile.style.backgroundColor = `var(${colorVar})`;
        tile.style.borderColor = `var(${borderVar})`;
        tile.style.color = isGuest
          ? `var(${borderVar})`
          : 'white';
      } else {
        const fallbackBg = isGuest
          ? `--domain-${domainIdLower}-light`
          : `--domain-${domainIdLower}`;

        tile.style.backgroundColor = `var(${fallbackBg})`;
        tile.style.borderColor = `var(--domain-${domainIdLower}-dark)`;
        tile.style.color = isGuest
          ? `var(--domain-${domainIdLower}-dark)`
          : 'white';
      }

      return tile;
    }

    // Apply learner status classes (achieved / planned / reach)
    function applyLearnerStatusToTile(tile){
      if(!tile) return;
      tile.classList.remove('cert-status-achieved','cert-status-planned','cert-status-reach');
      // Suppress any learner status visualization when learner mode is OFF
      if(!filterState.learnerMode) return;
      const cid = tile.getAttribute('data-cert-id');
      const status = window.learnerCertStatuses && window.learnerCertStatuses[cid];
      // Apply unified learner palette overriding domain colors for clarity
      if(status==='achieved'){
        tile.classList.add('cert-status-achieved');
        tile.style.backgroundColor = 'var(--color-green-light)';
        tile.style.borderColor = 'var(--color-green-dark)';
        tile.style.color = 'var(--color-green-dark)';
      } else if(status==='planned') {
        tile.classList.add('cert-status-planned');
        tile.style.backgroundColor = 'var(--color-yellow-light)';
        tile.style.borderColor = 'var(--color-yellow-dark)';
        tile.style.color = 'var(--color-yellow-dark)';
      } else if(status==='reach') {
        tile.classList.add('cert-status-reach');
        tile.style.backgroundColor = 'var(--color-skyblue-light)';
        tile.style.borderColor = 'var(--color-skyblue-dark)';
        tile.style.color = 'var(--color-skyblue-dark)';
      }
    }

    // Filter tiles based on learner view mode
    function updateLearnerViewVisibility(){
      /* View semantics (renamed):
         baseline (formerly default): show every cert tile; statuses still visually applied for assigned certs (only when learner mode ON)
         achieved/planned/reach: show only tiles with that status
         all: show only tiles that have ANY learner status (achieved/planned/reach)
      */
      const mode = filterState.learnerMode;
      const view = filterState.learnerView; // default|achieved|planned|reach|all
      document.querySelectorAll('.cert-tile').forEach(tile=>{
        if(!mode || view==='baseline'){ tile.style.display=''; return; }
        const cid = tile.getAttribute('data-cert-id');
        const status = window.learnerCertStatuses && window.learnerCertStatuses[cid];
        if(view==='all'){
          tile.style.display = (status==='achieved'||status==='planned'||status==='reach') ? '' : 'none';
        } else {
          tile.style.display = (status===view) ? '' : 'none';
        }
      });
    }

    function updateDomainCenteringClass(domains) {
      const body = document.body;
      const allDomainIds = domains.map(d => d.domainId);
      const visible = filterState.visibleDomains;

      const isSubset = visible.length > 0 && visible.length < allDomainIds.length;

      if (isSubset) {
        body.classList.add("center-domains");
      } else {
        body.classList.remove("center-domains");
      }
    }

    // Master redraw function — uses current filterState to rebuild roadmap
    function applyFiltersAndRedraw() {
      console.log("Redrawing with current filters:", filterState);

      const roadmapEl = document.getElementById("roadmap");
      roadmapEl.innerHTML = ""; // Clear all roadmap content

      updateDomainCenteringClass(window.loadedDomains);

      drawRoadmap(
        window.loadedDomains,
        window.loadedSubdomains,
        window.loadedCerts,
        window.loadedSkillStrata
      );
    }

    Promise.all([
      loadJSON('./data/domains.json'),
      loadJSON('./data/subdomains.json'),
      loadJSON('./data/certs.json'),
      loadJSON('./data/vendors.json'),
      loadJSON('./data/skillstrata.json'),
    ]).then(([domains, subdomains, certs, vendors, skillStrata]) => {

  // Seed visible domains excluding SKL (skill rail now replaces it)
  filterState.visibleDomains = domains.filter(d=> d.domainId !== 'SKL').map(d => d.domainId);
      // Populate domain checkboxes (styled as pill tiles)
      const domainCheckboxes = document.getElementById("domain-checkboxes");
      domainCheckboxes.classList.add('domain-filter-bar');
      domains.filter(d=> d.domainId !== 'SKL')
        .slice()
        .sort((a,b)=> a.domainDisplayOrder - b.domainDisplayOrder)
        .forEach(domain => {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `domain-${domain.domainId}`;
          checkbox.value = domain.domainId;
          checkbox.checked = true;

          const label = document.createElement('label');
          label.className = 'domain-filter-tile';
          label.htmlFor = checkbox.id;
          label.title = domain.domainShortName || domain.domainId; // tooltip with full name
          label.setAttribute('data-domain-id', domain.domainId);
          label.textContent = domain.domainId; // use abbreviated domainId text

          // Apply domain color styling
          const idLower = domain.domainId.toLowerCase();
          label.style.backgroundColor = `var(--domain-${idLower}-light)`;
          label.style.color = `var(--domain-${idLower}-dark)`;
          label.style.borderColor = `var(--domain-${idLower}-dark)`;

          // Insert checkbox inside label for larger click target
          label.appendChild(checkbox);

          function updateVisualState() {
            if (checkbox.checked) {
              label.classList.remove('is-off');
            } else {
              label.classList.add('is-off');
            }
          }

          checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
              if (!filterState.visibleDomains.includes(domain.domainId)) {
                filterState.visibleDomains.push(domain.domainId);
              }
            } else {
              filterState.visibleDomains = filterState.visibleDomains.filter(id => id !== domain.domainId);
            }
            updateVisualState();
            saveStateDebounced();
            applyFiltersAndRedraw();
          });

          updateVisualState();
          domainCheckboxes.appendChild(label);
        });
      // Normalize vendors before doing anything else
      const normalizedVendors = vendors.map(v => ({
        vendorId: v.id,
        vendorLabel: v.name
      }));
      window.normalizedVendors = normalizedVendors;

      // Seed visibleVendorIds with the correct values
      filterState.visibleVendorIds = normalizedVendors.map(v => v.vendorId);

      // Store for later use (for debugging or reuse)
      window.loadedDomains = domains;
      window.loadedSubdomains = subdomains;
      window.loadedSkillStrata = skillStrata;
      window.loadedCerts = certs;
      window.loadedVendors = vendors;          // Raw: [{ id, name }]
      window.normalizedVendors = normalizedVendors;  // Normalized: [{ vendorId, vendorLabel }]

      const vendorSelect = document.getElementById("vendor-filter");

      // Clear old options (if any)
      vendorSelect.innerHTML = "";

      // “All Vendors” option — FIRST and selected by default
        const allOption = document.createElement("option");
        allOption.value = "__ALL__";
        allOption.textContent = "All Vendors";
        allOption.selected = true; // default on page load
        vendorSelect.appendChild(allOption);

        // “None” option — SECOND
        const noneOption = document.createElement("option");
        noneOption.value = "__NONE__";
        noneOption.textContent = "None";
        vendorSelect.appendChild(noneOption);

      // Populate from normalizedVendors
      normalizedVendors.forEach(vendor => {
        const option = document.createElement("option");
        option.value = vendor.vendorId;
        option.textContent = vendor.vendorLabel || vendor.vendorId;
        vendorSelect.appendChild(option);
      });

      // Initial draw
      // Load persisted state AFTER UI elements exist
      const persisted = loadState();
      if(!persisted){
        // First visit: default to dark mode
        filterState.darkMode = true;
        document.body.classList.add('dark-mode');
        // Persist immediately so subsequent loads treat it as user state until they change it
        saveState();
      }
      applyPersistedState(persisted, domains, normalizedVendors);

      // Sync domain checkbox visual state after persistence load
      if (persisted && Array.isArray(persisted.visibleDomains)) {
        const currentVisible = new Set(filterState.visibleDomains);
        domains.forEach(d => {
          const cb = document.getElementById(`domain-${d.domainId}`);
          if (cb) {
            cb.checked = currentVisible.has(d.domainId);
            const tile = cb.parentElement;
            if (tile && tile.classList.contains('domain-filter-tile')) {
              if (cb.checked) tile.classList.remove('is-off'); else tile.classList.add('is-off');
            }
          }
        });
      }

      // Adjust vendor dropdown selection
      const vendorSelectEl = document.getElementById('vendor-filter');
      if (vendorSelectEl && filterState.selectedVendorMode) {
        vendorSelectEl.value = filterState.selectedVendorMode;
        // If custom single vendor persisted
        if (filterState.selectedVendorMode !== '__ALL__' && filterState.selectedVendorMode !== '__NONE__') {
          filterState.visibleVendorIds = [filterState.selectedVendorMode];
        } else if (filterState.selectedVendorMode === '__ALL__') {
          filterState.visibleVendorIds = normalizedVendors.map(v=>v.vendorId);
        } else if (filterState.selectedVendorMode === '__NONE__') {
          filterState.visibleVendorIds = [];
        }
      }

      // Build skill strata toggle pills (Beginner / Intermediate / Expert)
      const strataContainer = document.getElementById('strata-pills');
      strataContainer.classList.add('strata-filter-bar');
      const strataDefinitions = [
        { id: 'beginner', label: 'Beginner', light: '--strata-beginner-light', dark: '--strata-beginner-dark' },
        { id: 'intermediate', label: 'Intermediate', light: '--strata-intermediate-light', dark: '--strata-intermediate-dark' },
        { id: 'expert', label: 'Expert', light: '--strata-expert-light', dark: '--strata-expert-dark' }
      ];

      strataDefinitions.forEach(level => {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = `strata-${level.id}`;
        cb.value = level.id;
        cb.checked = filterState.visibleSkillStrata[level.id];

        const label = document.createElement('label');
        label.className = 'strata-filter-tile';
        label.htmlFor = cb.id;
        label.setAttribute('data-strata-id', level.id);
        label.title = `${level.label} skill level`; // tooltip
        label.textContent = level.label;
        label.appendChild(cb);

        function updateVisual() {
          if (cb.checked) {
            label.classList.remove('is-off');
            label.style.backgroundColor = `var(${level.light})`;
            label.style.color = `var(${level.dark})`;
            label.style.borderColor = `var(${level.dark})`;
          } else {
            label.classList.add('is-off');
            label.style.backgroundColor = 'transparent';
            label.style.color = '#555';
            label.style.borderColor = '#777';
          }
        }

        cb.addEventListener('change', () => {
          // Prevent all-off state (keep at least one level visible)
            cb.checked = cb.checked; // ensure state stable
          filterState.visibleSkillStrata[level.id] = cb.checked;
          if (!Object.values(filterState.visibleSkillStrata).some(v => v)) {
            // Re-enable this one to avoid blank roadmap
            filterState.visibleSkillStrata[level.id] = true;
            cb.checked = true;
          }
          updateVisual();
          saveStateDebounced();
          applyFiltersAndRedraw();
          updateStrataRailVisibility();
        });

        updateVisual();
        strataContainer.appendChild(label);
      });

  applyFiltersAndRedraw();
  updateStrataRailVisibility();
      saveStateDebounced(); // Ensure any missing new fields are persisted
    });

    // Recalibrate on viewport resize (debounced) to keep alignment accurate
    const recalibrateRailDebounced = debounce(() => {
      if (window.loadedSkillStrata) calibrateSkillStrataSegments(window.loadedSkillStrata);
    }, 120);
    window.addEventListener('resize', recalibrateRailDebounced);

//   BEGIN block this function //
//   // Checkbox: Cross-domain certs
//   document.getElementById("toggle-cross-domain").addEventListener("change", (e) => {
//     const isChecked = e.target.checked;
//     filterState.showCrossDomainCerts = isChecked;
//   
//     const subToggleContainer = document.getElementById("cross-cert-subtoggles");
//     const toggleCrossSub = document.getElementById("toggle-cross-subdomain");
//     const toggleOnlyCross = document.getElementById("toggle-only-cross-certs");
//   
//     if (isChecked) {
//       subToggleContainer.style.display = "inline-block";
//       toggleCrossSub.checked = true;
//       toggleOnlyCross.checked = true;
//       filterState.showCrossSubdomainCerts = true;
//       filterState.showOnlyCrossCerts = true;
//     } else {
//       subToggleContainer.style.display = "none";
//       toggleCrossSub.checked = false;
//       toggleOnlyCross.checked = false;
//       filterState.showCrossSubdomainCerts = false;
//       filterState.showOnlyCrossCerts = false;
//     }
//   
//     applyFiltersAndRedraw();
//   });
//   
//   // Checkbox: Cross-subdomain certs
//   document.getElementById("toggle-cross-subdomain").addEventListener("change", (e) => {
//     filterState.showCrossSubdomainCerts = e.target.checked;
//     applyFiltersAndRedraw();
//   });
//   // Checkbox: Cross-subdomain certs
//   document.getElementById("toggle-cross-subdomain").addEventListener("change", (e) => {
//     filterState.showCrossSubdomainCerts = e.target.checked;
//     applyFiltersAndRedraw();
//   });
//   // Checkbox: Show only cross-certs
//   document.getElementById("toggle-only-cross-certs").addEventListener("change", (e) => {
//     filterState.showOnlyCrossCerts = e.target.checked;
//     applyFiltersAndRedraw();
//   });
//   END block this function //

    // Vendor dropdown
    document.getElementById("vendor-filter").addEventListener("change", (e) => {
    const selected = e.target.value;

    if (selected === "__NONE__") {
      // “None” was selected → show zero certs
      filterState.visibleVendorIds = [];
    } else if (selected === "__ALL__") {
      // “All Vendors” was selected → reset to every vendorId
      filterState.visibleVendorIds = window.normalizedVendors.map(v => v.vendorId);
    } else {
      // A single vendorId was selected → filter to just that one
      filterState.visibleVendorIds = [selected];
    }
      filterState.selectedVendorMode = selected;
      saveStateDebounced();

    applyFiltersAndRedraw();
  });

  // Build Light/Dark mode two-state pill pair
  const modePills = document.getElementById('mode-pills');
  if (modePills) {
    // Modes array defined without static active flags; active resolved each render so early body class changes are reflected
    const modes = [
      { id: 'light', label: 'Light', light: '--mode-light-light', dark: '--mode-light-dark' },
      { id: 'dark', label: 'Dark', light: '--mode-dark-light', dark: '--mode-dark-dark' }
    ];
    function renderModePills() {
      modePills.innerHTML='';
      modes.forEach(m => {
        const cb = document.createElement('input');
        cb.type='radio';
        cb.name='display-mode';
        cb.id=`mode-${m.id}`;
        cb.checked = (m.id==='dark') === filterState.darkMode; // dark is checked when darkMode true
        const label = document.createElement('label');
        label.className='mode-filter-tile';
        label.htmlFor=cb.id;
        label.textContent=m.label;
        label.appendChild(cb);
        function updateVisual(){
          if (cb.checked){
            label.classList.remove('is-off');
            label.style.backgroundColor=`var(${m.light})`;
            label.style.color=`var(${m.dark})`;
            label.style.borderColor=`var(${m.dark})`;
          } else {
            label.classList.add('is-off');
            label.style.background='transparent';
            label.style.color='#555';
            label.style.borderColor='#777';
          }
        }
        cb.addEventListener('change', ()=>{
          if (!cb.checked) return;
          filterState.darkMode = (m.id === 'dark');
            document.body.classList.toggle('dark-mode', filterState.darkMode);
          saveStateDebounced();
          renderModePills(); // re-render to refresh visuals uniformly
        });
        updateVisual();
        modePills.appendChild(label);
      });
    }
    renderModePills();
  }

  // Collapsible filter stack behavior
  const filterStack = document.getElementById('filters-secondary');
  const filterToggle = document.getElementById('filter-stack-toggle');
  const filterArrow = document.getElementById('filter-stack-arrow');
  function applyFilterStackState() {
    const expanded = filterState.filtersExpanded;
    if (filterStack) filterStack.classList.toggle('collapsed', !expanded);
    if (filterToggle) filterToggle.setAttribute('aria-expanded', expanded ? 'true':'false');
    if (filterArrow) {
      filterArrow.style.transform = expanded ? 'rotate(0deg)' : 'rotate(-90deg)';
    }
    const lines = document.getElementById('filter-stack-lines');
    if (lines) {
      lines.style.display = expanded ? '' : 'none';
    }
    console.log('[Filters] applyFilterStackState expanded=', expanded);
  }
  if (filterToggle) {
    const toggleFn = () => { filterState.filtersExpanded = !filterState.filtersExpanded; applyFilterStackState(); saveStateDebounced(); };
    filterToggle.addEventListener('click', toggleFn);
    filterToggle.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); toggleFn(); }});
  }
  applyFilterStackState();

  // ================= Learner Mode Stack / Logic =================
  const learnerStack = document.getElementById('learner-stack');
  const learnerToggleHeader = document.getElementById('learner-stack-toggle');
  const learnerArrow = document.getElementById('learner-stack-arrow');
  function applyLearnerStackState(){
    const expanded = filterState.learnerStackExpanded;
    if (learnerStack) learnerStack.classList.toggle('collapsed', !expanded);
    const lines = document.getElementById('learner-stack-lines');
    if (lines) lines.style.display = expanded ? '' : 'none';
    if (learnerToggleHeader) learnerToggleHeader.setAttribute('aria-expanded', expanded? 'true':'false');
    if (learnerArrow) learnerArrow.style.transform = expanded ? 'rotate(0deg)' : 'rotate(-90deg)';
  }
  if (learnerToggleHeader){
    const toggleLearner = () => { filterState.learnerStackExpanded = !filterState.learnerStackExpanded; applyLearnerStackState(); saveStateDebounced(); };
    learnerToggleHeader.addEventListener('click', toggleLearner);
    learnerToggleHeader.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggleLearner(); }});
  }
  applyLearnerStackState();

  const learnerModePills = document.getElementById('learner-mode-pills');
  function renderLearnerModePills(){
    if(!learnerModePills) return; learnerModePills.innerHTML='';
    const modes=[{id:'off',label:'Off',active:!filterState.learnerMode},{id:'on',label:'On',active:filterState.learnerMode}];
    modes.forEach(m=>{
      const input=document.createElement('input'); input.type='radio'; input.name='learner-mode'; input.id=`learner-mode-${m.id}`; input.checked=m.active; input.style.display='none';
      const label=document.createElement('label'); label.className='mode-filter-tile'; label.htmlFor=input.id; label.textContent=m.label; label.appendChild(input);
      function style(){
        // Unified palette-based styling (same in light & dark mode)
        const greenBg='var(--color-green-light)';
        const greenBorder='var(--color-green-dark)';
        const greenText='var(--color-green-dark)';
        const redBg='var(--color-red-light)';
        const redBorder='var(--color-red-dark)';
        const redText='var(--color-red-dark)';
        if(input.checked){
          label.classList.remove('is-off');
          if(m.id==='on'){
            label.style.background=greenBg;
            label.style.borderColor=greenBorder;
            label.style.color=greenText;
          } else {
            label.style.background=redBg;
            label.style.borderColor=redBorder;
            label.style.color=redText;
          }
        } else {
          label.classList.add('is-off');
          label.style.background='transparent';
          label.style.color='#555';
          label.style.borderColor='#777';
        }
      }
      input.addEventListener('change',()=>{ if(!input.checked) return; const turningOn = (m.id==='on'); filterState.learnerMode = turningOn; console.debug('[LearnerMode] toggled ->', filterState.learnerMode); if(!filterState.learnerMode){
          // When turning OFF, force roadmap back to Default view semantics
          filterState.learnerView = 'baseline';
          removeLearnerPopup();
          // Strip learner inline styles & classes so roadmap returns to native palette
          document.querySelectorAll('.cert-tile').forEach(t=>{
            t.classList.remove('cert-status-achieved','cert-status-planned','cert-status-reach');
            t.style.backgroundColor='';
            t.style.borderColor='';
            t.style.color='';
          });
          // Rebuild roadmap immediately so domain palette reapplies without waiting for another filter interaction
          const prevScrollY = window.scrollY; const prevScrollX = window.scrollX;
          applyFiltersAndRedraw();
          window.scrollTo(prevScrollX, prevScrollY);
        }
        updateLearnerModeStatusBadge();
        saveStateDebounced();
        renderLearnerModePills();
        renderLearnerActionPills();
        updateLearnerViewVisibility();
      });
      // Redundant label click safety (some browsers swallow hidden input change under rapid clicks)
      label.addEventListener('click', (ev)=>{ if(!input.checked){ input.checked=true; input.dispatchEvent(new Event('change',{bubbles:true})); } ev.stopPropagation(); });
      style(); learnerModePills.appendChild(label);
    });
  }
  renderLearnerModePills();

  const learnerActionPills = document.getElementById('learner-action-pills');
  function getLearnerStatusCounts(){
    let achieved=0, planned=0, reach=0; const statuses = window.learnerCertStatuses||{};
    for(const v of Object.values(statuses)){ if(v==='achieved') achieved++; else if(v==='planned') planned++; else if(v==='reach') reach++; }
    return {achieved, planned, reach};
  }
  function renderLearnerActionPills(){
    if(!learnerActionPills) return; learnerActionPills.innerHTML='';
    const neutralBg = 'var(--learner-neutral-bg)';
    const neutralBorder = 'var(--learner-neutral-border)';
    const neutralText = 'var(--learner-neutral-text)';
    const counts = getLearnerStatusCounts();
    const views=[
      {id:'baseline', label:'Baseline', bg:neutralBg, border:neutralBorder, text:neutralText},
      {id:'achieved', label:`My Achieved (${counts.achieved})`, bg:'var(--color-green-light)', border:'var(--color-green-dark)', text:'var(--color-green-dark)'},
      {id:'planned', label:`My Planned (${counts.planned} of ${MAX_PLANNED_CERTS})`, bg:'var(--color-yellow-light)', border:'var(--color-yellow-dark)', text:'var(--color-yellow-dark)', dashed:true},
      {id:'reach', label:`My Reach Goal (${counts.reach} of 1)`, bg:'var(--color-blue-light)', border:'var(--color-blue-dark)', text:'var(--color-blue-dark)'},
      {id:'all', label:'My Roadmap', bg:neutralBg, border:neutralBorder, text:neutralText},
      {id:'reset', label:'Reset', bg:neutralBg, border:neutralBorder, text:neutralText}
    ];
    views.forEach(v=>{
      const input=document.createElement('input'); input.type='radio'; input.name='learner-view'; input.id=`learner-view-${v.id}`; input.style.display='none';
      if(v.id!=='reset'){ input.checked = (filterState.learnerView===v.id); }
      const label=document.createElement('label'); label.className='mode-filter-tile'; label.htmlFor=input.id; label.textContent=v.label; label.appendChild(input);
      function paint(){
        const active = v.id==='reset' ? false : input.checked;
        if(active){
          label.classList.remove('is-off');
          label.style.background=v.bg; label.style.borderColor=v.border; label.style.color=v.text;
          label.style.borderStyle = v.dashed ? 'dashed' : 'solid';
        } else {
          label.classList.add('is-off');
          label.style.background='transparent'; label.style.borderColor='#777'; label.style.color='#555';
          label.style.borderStyle='solid';
        }
        if(!filterState.learnerMode){ label.style.opacity='.45'; } else { label.style.opacity='1'; }
      }
      if(v.id==='reset'){
        label.addEventListener('click',(e)=>{ e.stopPropagation(); if(!filterState.learnerMode){ return; } showLearnerResetModal(); });
      } else {
  input.addEventListener('change',()=>{ if(!input.checked) return; filterState.learnerView=v.id; saveStateDebounced(); renderLearnerActionPills(); updateLearnerViewVisibility(); });
        label.addEventListener('click', (e)=>{ if(!filterState.learnerMode){ return; } if(!input.checked){ input.checked=true; input.dispatchEvent(new Event('change',{bubbles:true})); } e.stopPropagation(); });
      }
      // Disable non-default view pills when learner mode is OFF
      if(!filterState.learnerMode){
        if(v.id==='baseline'){
          // Force default to appear active
          input.checked = true;
          label.classList.remove('is-off');
          label.style.background = v.bg; label.style.borderColor = v.border; label.style.color = v.text; label.style.borderStyle = v.dashed ? 'dashed' : 'solid';
          label.setAttribute('aria-current','true');
        } else if(v.id!=='reset') {
          label.style.pointerEvents='none';
          label.setAttribute('aria-disabled','true');
          label.title = 'Enable Learner Mode to use this filter';
        } else { // reset pill
          label.style.pointerEvents='none';
          label.setAttribute('aria-disabled','true');
          label.title = 'Enable Learner Mode to reset statuses';
        }
      }
      paint(); learnerActionPills.appendChild(label);
    });
  }
  renderLearnerActionPills();

  // Status badge (debug / feedback)
  const learnerStatusBadge = document.createElement('div');
  learnerStatusBadge.id = 'learner-mode-status';
  learnerStatusBadge.className = 'learner-status-badge learner-status-off';
  const optionsHeader = document.getElementById('learner-stack-toggle');
  if(optionsHeader){
    // Insert badge at end of Options (learner) stack header, preserving existing content
    optionsHeader.appendChild(learnerStatusBadge);
  }
  function updateLearnerModeStatusBadge(){
    if(!learnerStatusBadge) return;
    const on = !!filterState.learnerMode;
  learnerStatusBadge.textContent = on ? 'Learner ON' : 'Learner OFF';
    learnerStatusBadge.classList.toggle('learner-status-on', on);
    learnerStatusBadge.classList.toggle('learner-status-off', !on);
    learnerStatusBadge.setAttribute('aria-label', on ? 'Learner Mode is ON' : 'Learner Mode is OFF');
  }
  updateLearnerModeStatusBadge();

  // ================= Reset Modal (for learner statuses) =================
  function showLearnerResetModal(){
    // Remove existing if any
    const existing = document.querySelector('.learner-reset-overlay');
    if(existing) existing.remove();
    const overlay = document.createElement('div');
    overlay.className='learner-reset-overlay';
    overlay.innerHTML = `\n      <div class="learner-reset-dialog" role="dialog" aria-modal="true" aria-labelledby="learner-reset-title">\n        <h3 id="learner-reset-title">Reset Learner Selections?</h3>\n        <p>This will clear ALL Achieved / Planned / Reach Goal statuses you have set. This action cannot be undone. Are you sure you want to proceed?</p>\n        <div class="learner-reset-actions">\n          <button type="button" class="learner-reset-btn cancel" data-action="cancel">Cancel</button>\n          <button type="button" class="learner-reset-btn confirm" data-action="confirm">Yes, Reset</button>\n        </div>\n      </div>`;
    document.body.appendChild(overlay);
    const dialog = overlay.querySelector('.learner-reset-dialog');
    // Focus management
    const cancelBtn = overlay.querySelector('[data-action="cancel"]');
    const confirmBtn = overlay.querySelector('[data-action="confirm"]');
    cancelBtn.focus();
    function close(){ overlay.remove(); }
    function doReset(){
      window.learnerCertStatuses = {}; // clear statuses in memory
      saveLearnerStatuses();
      // Reset learnerView to 'all' so user sees zero (since no statuses remain)
  filterState.learnerView = 'all'; // remains the same semantic (All My Certs)
      saveStateDebounced();
      document.querySelectorAll('.cert-tile').forEach(tile=>{ applyLearnerStatusToTile(tile); });
      renderLearnerActionPills();
      updateLearnerViewVisibility();
      close();
    }
    overlay.addEventListener('click', e=>{ if(e.target===overlay) close(); });
    cancelBtn.addEventListener('click', close);
    confirmBtn.addEventListener('click', doReset);
    overlay.addEventListener('keydown', e=>{
      if(e.key==='Escape'){ e.preventDefault(); close(); }
      if(e.key==='Enter' && document.activeElement===confirmBtn){ e.preventDefault(); doReset(); }
    });
  }

  // Popup menu for status changes
  let currentLearnerPopup=null;
  function removeLearnerPopup(){ if(currentLearnerPopup && currentLearnerPopup.parentNode){ currentLearnerPopup.parentNode.removeChild(currentLearnerPopup); currentLearnerPopup=null; } }
  function createLearnerPopup(tile){
    console.debug('[LearnerPopup] create invoked for certId=', tile && tile.getAttribute('data-cert-id'));
    removeLearnerPopup();
    const rect=tile.getBoundingClientRect();
    const menu=document.createElement('div');
    menu.className='learner-popup-menu'; menu.setAttribute('role','menu');
    function addBtn(label,fn,cls){ const b=document.createElement('button'); b.type='button'; b.textContent=label; if(cls)b.classList.add(cls); b.addEventListener('click',e=>{ e.stopPropagation(); fn(); removeLearnerPopup(); }); menu.appendChild(b); }
    const cid=tile.getAttribute('data-cert-id');
  addBtn('Mark as Achieved',()=>{
    const prev = window.learnerCertStatuses[cid];
    if(prev==='planned') removePlannedCertFromOrder(cid); // leaving planned → achieved
    // If previously reach, just overwrite.
    window.learnerCertStatuses[cid]='achieved';
    applyLearnerStatusToTile(tile);
    saveLearnerStatuses();
    updateLearnerViewVisibility();
    renderLearnerActionPills();
  },null);
  addBtn('Mark as Planned',()=>{
    // Planned selection with cap + replacement confirmation when at limit
    const currentStatus = window.learnerCertStatuses[cid];
    if(currentStatus==='planned') return; // already planned
    // If shifting from reach or achieved, that's fine; only need to add to order if not already.
    if(currentStatus==='reach'){ /* reach → planned */ }
    if(currentStatus==='achieved'){ /* achieved → planned is allowed, rare */ }
    const plannedIds = window.learnerPlannedOrder.slice();
    if(plannedIds.length < MAX_PLANNED_CERTS){
      window.learnerCertStatuses[cid]='planned';
      addPlannedCertToOrder(cid);
      applyLearnerStatusToTile(tile);
      saveLearnerStatuses();
      updateLearnerViewVisibility();
      renderLearnerActionPills();
    } else {
      const oldestId = plannedIds[0];
      if(oldestId===cid){ return; }
      const oldestTile = document.querySelector(`.cert-tile[data-cert-id="${oldestId}"]`);
      const oldestName = oldestTile ? oldestTile.textContent.trim() : oldestId;
      const newName = tile.textContent.trim();
      showPlannedLimitModal(oldestId,cid,newName,oldestName,()=>{
        // Replace logic
        if(window.learnerCertStatuses[oldestId]==='planned') delete window.learnerCertStatuses[oldestId];
        removePlannedCertFromOrder(oldestId);
        window.learnerCertStatuses[cid]='planned';
        addPlannedCertToOrder(cid);
        if(oldestTile) applyLearnerStatusToTile(oldestTile);
        applyLearnerStatusToTile(tile);
        saveLearnerStatuses();
        updateLearnerViewVisibility();
        renderLearnerActionPills();
      });
    }
  },null);
  addBtn('Mark as Reach Goal',()=>{
    const existingId = getCurrentReachGoalCertId();
    const priorStatus = window.learnerCertStatuses[cid];
    if(existingId && existingId !== cid){
      // Need tile names for dialog messaging
      const existingTile = document.querySelector(`.cert-tile[data-cert-id="${existingId}"]`);
      const existingName = existingTile ? existingTile.textContent.trim() : existingId;
      const newName = tile.textContent.trim();
      showReachReplaceConfirm(existingId,cid,newName,existingName,()=>{
        delete window.learnerCertStatuses[existingId];
        if(priorStatus==='planned') removePlannedCertFromOrder(cid); // planned → reach
        window.learnerCertStatuses[cid]='reach';
        applyLearnerStatusToTile(tile);
        if(existingTile) applyLearnerStatusToTile(existingTile); // clear old styling
        saveLearnerStatuses();
        updateLearnerViewVisibility();
        renderLearnerActionPills();
      });
    } else {
      if(priorStatus==='planned') removePlannedCertFromOrder(cid); // planned → reach
      window.learnerCertStatuses[cid]='reach';
      applyLearnerStatusToTile(tile);
      saveLearnerStatuses();
      updateLearnerViewVisibility();
      renderLearnerActionPills();
    }
  },null);
  addBtn('Clear Status',()=>{ 
    const status = window.learnerCertStatuses[cid];
    if(status==='planned') removePlannedCertFromOrder(cid);
    if(status==='reach') {/* reach replacement handled elsewhere */}
    delete window.learnerCertStatuses[cid]; 
    applyLearnerStatusToTile(tile); 
    saveLearnerStatuses(); 
    updateLearnerViewVisibility(); 
    renderLearnerActionPills();
  },'danger');
    document.body.appendChild(menu);
    // ----- Viewport-safe positioning -----
    const viewportW = document.documentElement.clientWidth;
    const viewportH = document.documentElement.clientHeight;
    const scrollX = window.scrollX; const scrollY = window.scrollY;
    const margin = 6; // minimum gap from tile, also used as viewport inset
    // Initial preferred position: below, horizontally centered on tile
    let top = rect.bottom + margin + scrollY;
    let left = rect.left + (rect.width/2) - (menu.offsetWidth/2) + scrollX;
    // Clamp horizontally so popup fully visible
    if(left < margin + scrollX) left = margin + scrollX;
    const maxLeft = scrollX + viewportW - menu.offsetWidth - margin;
    if(left > maxLeft) left = Math.max(margin + scrollX, maxLeft);
    // If bottom overflows viewport, try placing above the tile
    const menuHeight = menu.offsetHeight;
    if(top + menuHeight - scrollY > viewportH - margin){
      const flippedTop = rect.top - menuHeight - margin + scrollY;
      if(flippedTop >= margin + scrollY){
        top = flippedTop;
        menu.classList.add('placement-above'); // (optional styling hook)
      } else {
        // Constrain height if still doesn't fit (rare on very small viewports)
        const availableBelow = viewportH - rect.bottom - (margin*2);
        const availableAbove = rect.top - (margin*2);
        let maxHeight = Math.max(availableBelow, availableAbove);
        if(maxHeight < menuHeight){
          menu.style.maxHeight = Math.max(80, maxHeight) + 'px';
          menu.style.overflowY = 'auto';
        }
        // Choose side with more space
        if(availableAbove > availableBelow){
          top = Math.max(margin + scrollY, rect.top - (menu.offsetHeight || maxHeight) - margin + scrollY);
          menu.classList.add('placement-above');
        } else {
          top = rect.bottom + margin + scrollY;
        }
      }
    }
    // Final clamp vertically (in case of resize between measurements)
    const minTop = margin + scrollY;
    const maxTop = scrollY + viewportH - menu.offsetHeight - margin;
    if(top < minTop) top = minTop;
    if(top > maxTop) top = Math.max(minTop, maxTop);
    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
    currentLearnerPopup=menu;
  }
  document.addEventListener('click',e=>{ if(currentLearnerPopup && !currentLearnerPopup.contains(e.target)) removeLearnerPopup(); });
  document.addEventListener('keydown',e=>{ if(e.key==='Escape') removeLearnerPopup(); });

  // Intercept cert tile clicks in learner mode
  document.addEventListener('click',(e)=>{
    const tile=e.target.closest('.cert-tile');
    if(!tile) return; // not a cert click
    // Only act on unmodified primary button clicks
    if(e.button!==0 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
    if(filterState.learnerMode){
      e.preventDefault();
      console.debug('[LearnerMode] Popup via delegated click. learnerMode=', filterState.learnerMode);
      createLearnerPopup(tile);
    } else {
      const href = tile.getAttribute('href');
      console.debug('[LearnerMode] Normal nav attempt (learner OFF) href=', href, 'defaultPrevented?', e.defaultPrevented);
      if(!href){ console.warn('[LearnerMode] Tile missing href attribute; cannot navigate. certId=', tile.getAttribute('data-cert-id')); }
      // Do NOT call preventDefault here. Allow browser default.
    }
  }, false);

  // Capture-phase safeguard: if some earlier code prevented default while learnerMode is OFF, force navigation.
  document.addEventListener('click',(e)=>{
    const tile=e.target.closest('.cert-tile');
    if(!tile) return;
    if(filterState.learnerMode) return; // Only safeguard when OFF
    if(e.button!==0 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return; // only plain left clicks
    const href = tile.getAttribute('href');
    if(!href) return;
    if(e.defaultPrevented){
      console.debug('[LearnerMode][Safeguard] defaultPrevented detected while OFF. Forcing navigation to', href);
      // Manual navigation fallback
      try { window.open(href, tile.target || '_blank'); } catch(err){ console.warn('[LearnerMode][Safeguard] window.open failed', err); }
    }
  }, true);

  // (Replaced with safeguard above)
  document.addEventListener('contextmenu',(e)=>{
    const tile=e.target.closest('.cert-tile');
    if(!tile) return;
    if(filterState.learnerMode){ e.preventDefault(); console.debug('[LearnerMode] contextmenu popup'); createLearnerPopup(tile);} }
  );

  window.addEventListener('load',()=>{ setTimeout(()=>{ document.querySelectorAll('.cert-tile').forEach(applyLearnerStatusToTile); },100); });
  
  // ==============================
  // Single Reach Goal Enforcement
  // Option 3 UX: Confirm replacement
  // ==============================
  function getCurrentReachGoalCertId(){
    for(const [cid,status] of Object.entries(window.learnerCertStatuses||{})){
      if(status==='reach') return cid;
    }
    return null;
  }

  function enforceSingleReachGoal(){
    // If multiple reach goals somehow exist (older sessions), keep the first encountered
    let first=null; const removals=[];
    for(const [cid,status] of Object.entries(window.learnerCertStatuses||{})){
      if(status==='reach'){
        if(first===null) first=cid; else removals.push(cid);
      }
    }
    if(removals.length){
      removals.forEach(r=>{ delete window.learnerCertStatuses[r]; });
      saveLearnerStatuses();
    }
  }

  function showReachReplaceConfirm(oldId,newId,newName,oldName,onConfirm){
    // Reuse styling pattern from learner-reset-dialog
    const overlay=document.createElement('div');
    overlay.className='learner-reset-overlay reach-replace-overlay';
    overlay.setAttribute('role','dialog');
    overlay.setAttribute('aria-modal','true');
    overlay.setAttribute('aria-label','Confirm Reach Goal Replacement');
    const dialog=document.createElement('div');
    dialog.className='learner-reset-dialog reach-replace-dialog';
    const title=document.createElement('h3');
    title.textContent='Replace Reach Goal?';
    const p=document.createElement('p');
    p.innerHTML = oldName
      ? `You already set <strong>${oldName}</strong> as your Reach Goal. Do you want to replace it with <strong>${newName}</strong>?`
      : `Confirm setting <strong>${newName}</strong> as your Reach Goal.`; // fallback (should not hit when oldId exists)
    const actions=document.createElement('div');
    actions.className='learner-reset-actions';
    const cancel=document.createElement('button');
    cancel.className='learner-reset-btn cancel';
    cancel.type='button';
    cancel.textContent='Cancel';
    cancel.addEventListener('click',()=>{ document.body.removeChild(overlay); });
    const confirm=document.createElement('button');
    confirm.className='learner-reset-btn confirm';
    confirm.type='button';
    confirm.textContent='Replace';
    confirm.addEventListener('click',()=>{ document.body.removeChild(overlay); onConfirm(); });
    actions.appendChild(cancel); actions.appendChild(confirm);
    dialog.appendChild(title); dialog.appendChild(p); dialog.appendChild(actions);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    // Basic focus management
    setTimeout(()=>confirm.focus(),30);
  }

  // Run enforcement early after statuses loaded
  enforceSingleReachGoal();
  enforceLegacyPlannedLimit();

  // ==============================
  // Planned Limit Replacement Modal
  // ==============================
  function showPlannedLimitModal(oldestId,newId,newName,oldestName,onConfirm){
    const overlay=document.createElement('div');
    overlay.className='learner-reset-overlay planned-limit-overlay';
    overlay.setAttribute('role','dialog');
    overlay.setAttribute('aria-modal','true');
    overlay.setAttribute('aria-label','Planned Certifications Limit');
    const dialog=document.createElement('div');
    dialog.className='learner-reset-dialog planned-limit-dialog';
    const title=document.createElement('h3'); title.textContent='Planned Focus Limit';
    const p=document.createElement('p');
    p.innerHTML=`You already have <strong>${MAX_PLANNED_CERTS}</strong> certifications planned. Replace the oldest (<strong>${oldestName}</strong>) with <strong>${newName}</strong>?`;
    const actions=document.createElement('div'); actions.className='learner-reset-actions';
    const cancel=document.createElement('button'); cancel.type='button'; cancel.className='learner-reset-btn cancel'; cancel.textContent='Cancel';
    cancel.addEventListener('click',()=>{ document.body.removeChild(overlay); });
    const replace=document.createElement('button'); replace.type='button'; replace.className='learner-reset-btn confirm'; replace.textContent='Replace';
    replace.addEventListener('click',()=>{ document.body.removeChild(overlay); onConfirm(); });
    actions.appendChild(cancel); actions.appendChild(replace);
    dialog.appendChild(title); dialog.appendChild(p); dialog.appendChild(actions);
    overlay.appendChild(dialog); document.body.appendChild(overlay);
    setTimeout(()=>replace.focus(),30);
  }

  // Fallback: attach per-tile listeners after each redraw to guarantee popup
  // Remove complex per-tile binding: delegation now handles all clicks.

</script>